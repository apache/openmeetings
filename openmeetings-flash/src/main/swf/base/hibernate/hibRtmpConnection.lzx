<?xml version="1.0" encoding="UTF-8" ?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at
  
	  http://www.apache.org/licenses/LICENSE-2.0
		  
  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
  
-->
<library>
	
<class name="userStatus" extends="view" width="250" height="30">
	<attribute name="statusText" type="string" />
	<attribute name="statusColor" type="number" value="0" />

	<text name="status" width="240" height="20" x="5" y="5" fontstyle="bold" fgcolor="0" text="defaulttext" fontsize="10"/>

	<handler name="oninit">
		this.status.setAttribute("text", this.statusText);
		this.status.setAttribute("fgcolor", this.statusColor);
		this.setAttribute("visibility", "visible");
		lz.Timer.addTimer( new LzDelegate( this, "selfDestroy" ), 3000 );
	</handler>

	<method name="selfDestroy" args="ignore=null">
		this.destroy();
	</method>
</class>

<class name="hibRtmpConnection" extends="rtmpConnection" debug="false" src="$once{ this.getUrl() }" >
	<switch>
		<when property="$as3">
			<passthrough>
				import flash.system.Capabilities;
				import flash.external.ExternalInterface;
			</passthrough>
		</when>
	</switch>
	<attribute name="counterror" type="number" value="0" />
	
	<attribute name="loaderVar" value="null" />
	
	<attribute name="userScope" value="hibernate" type="string" />
	
	<!-- refreshing the session regulary -->
	<attribute name="refreshDelegate" value="null" />
	
	<!-- UserId-->
	<attribute name="UserID" value="1" type="number" />
	<!-- reconnect after each conferenceView -->
	<attribute name="reconnectedRoomInstance" value="null" />
	
	<attribute name="reconnectionAction" value="false" type="boolean" />
	<attribute name="reconnectObjRef" value="null" />
		 
	 <attribute name="userobject" value="null" />
	 
	 <!-- default will be loaded on startup -->
	 <attribute name="userlang" value="1" type="number" />
	 
	 <!-- The default Language will be loaded on init  -->
	 <attribute name="initlanguageLoaded" value="false" type="boolean" />
	 
	 <!-- This domain is the orgdomain used in the video-conference -->
	 <attribute name="conferencedomain" value="public" type="string" />
	 
	 <!-- if this connection is used for testing the app
	 see test-setup.lzx -->
	 <attribute name="testAppLoading" value="false" type="boolean" />
	 
	 <!-- 
		the real ROOM_ID
	 -->
	 <attribute name="currentroomid" value="0" type="number" />
	 
	 <!--- the current Invitation-Object -->
	 <attribute name="currentInvitation" value="null" />
	
	<!-- shows what kind of conferenceView it is at the moment
		wether its conferenceView or audienceView -->
	<attribute name="modus" value="" type="string" />
	
	<attribute name="showKickMessage" value="false" type="boolean"/>
	<attribute name="showFullMessage" value="false" type="boolean"/>
		 
	<attribute name="useRTMPT" value="false" type="boolean" />
	<attribute name="connected" value="false" type="boolean" />
	
	<method name="getProtocol">
		if (canvas.useSSL) {
			return "rtmps";
		}
		if (this.useRTMPT) {
			return "rtmpt";
		}
		return "rtmp";
	</method>
	
	<method name="getPort">
		if (canvas.useSSL) {
			return canvas.rtmpsslport;
		}
		if (this.useRTMPT) {
			return canvas.red5httpport;
		}
		return canvas.rtmpport;
	</method>
	
	<method name="getHost">
		return canvas.rtmphostlocal;
	</method>
	
	<method name="getWebappRootKey">
		return canvas.webAppRootKey;
	</method>
		 
	<!-- 
		canvas.getUrl() can not be reused since it has different protocol and port 
		and potentially in cluster another host, the only thing that stays the same
		no matter if hosted on slave or on master, is the scope, so
		userScope always stays the same
	 -->
	<method name="getUrl">
		return this.getProtocol() + '://' + this.getHost() + ':' + this.getPort() 
					+ '/' + this.getWebappRootKey() + '/' + this.userScope;
	</method>
			 
	 <!--
		The onconnect Method is triggered several times:
			 - When you enter a room the NetConnection will close and reconnect to the Scope of the Room
			 - When you leave the room again it will be re-connected to the default scope again
	  -->
	 <handler name="onconnect">
		if($debug) Debug.write("hibRtmpConnection/onconnect");
		if (this.reconnectionAction){
			if (canvas.wicketsid == null) {
				this.overwritePublicSID.doCall();
				this.setUsernameReconnect.doCall();
			} else {
				canvas.sessionId = canvas.wicketsid;
				this.getPublicSID.doCall();
			}
		} else if (canvas.wicketsid != null) {
			canvas.sessionId = canvas.wicketsid;
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.setProgress();
			}
			this.getPublicSID.doCall();
		} else {
			this.refreshDelegate = new LzDelegate(this, "refreshSessionMeth");
			lz.Timer.addTimer(this.refreshDelegate, canvas.refreshSession);
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.setProgress();
			}
			
			//Load Session Data
			this.getsessiondata.doCall();	
		}
		connected = true;
		client.setNewBroadCastingFlag = this.setNewBroadCastingFlag;
		client.roomConnect = this.roomConnect;
		client.roomDisconnect = this.roomDisconnect;
		client.addNewUser = this.addNewUser;
		client.sendVarsToMessage = this.sendVarsToMessage;
		client.sendVarsToMessageWithClient = this.sendVarsToMessageWithClient;
		client.sendVarsToWhiteboardById = this.sendVarsToWhiteboardById;
		client.sendVarsToModeratorGeneral = this.sendVarsToModeratorGeneral;
		client.sendSyncFlag = this.sendSyncFlag;
		client.sendSyncCompleteFlag = this.sendSyncCompleteFlag;
		client.sendObjectSyncFlag = this.sendObjectSyncFlag;
		client.sendObjectSyncCompleteFlag = this.sendObjectSyncCompleteFlag;
		client.startedRecording = this.startedRecording;
		client.loadWmlToWhiteboardById = this.loadWmlToWhiteboardById;
		client.newMessageByRoomAndDomain = this.newMessageByRoomAndDomain;
		client.interviewStatus = this.interviewStatus;
		client.newStream = this.newStream;
		//TODO FIXME method is absent :( client.stopStream = this.stopStream;
		//TODO FIXME method is absent :( sendImagesSyncCompleteFlag
		client.receiveExclusiveAudioFlag = this.receiveExclusiveAudioFlag;
		client.setNewModeratorByList = this.setNewModeratorByList;
		client.newScreenSharing = this.newScreenSharing;
		client.stopScreenSharingMessage = this.stopScreenSharingMessage;
		client.stopRecordingMessage = this.stopRecordingMessage;
		client.stopPublishingMessage = this.stopPublishingMessage;
		client.newRed5ScreenCursor = this.newRed5ScreenCursor;
		client.nickNameSet = this.nickNameSet;
		client.clearChatContent = this.clearChatContent;
		client.startedPublishing = this.startedPublishing;
		client.newPoll = this.newPoll;
	</handler>
	
	<handler name="ondisconnect">
		connected = false;
	</handler>
	
	<method name="reconnectComplete">
		if (this.reconnectionAction){
			this.reconnectionAction = false;
		}
		canvas.currentContentView.sendInit.sendEvent(this);
	</method>
	
	<handler name="onerror" >
	<![CDATA[
		canvas.remoteLogWrite("error status='" + this.status + "'; src='" + this.src + "'; lastCalled='" + this.lastCalled
			+ "'; showKickMessage='" + this.showKickMessage + "'; showFullMessage='" + this.showFullMessage
			+ "'; reconnectionAction='" + this.reconnectionAction + "'");
		if (this.showFullMessage) {
			new lz.labelerrorPopup(canvas,
				{
					errorlabelid: 99
					, closeFunc: function() {
					   if (this.makeModal) {
						   lz.ModeManager.releaseAll();
					   }
					   if ($debug) Debug.write("Error dialog is being closed, calling QUIT");
					   canvas.commonVideoViewContent.immediateExitRoom(true,null);
					}
				});
			this.showFullMessage = false;
			return;
		} else if (this.showKickMessage) {
			new lz.labelerrorPopup(canvas,{
				errorlabelid:606
				, closeFunc: function() {
					canvas.quit();
				}
			});
			canvas._loadingAll.hideContentOnly();
			return;
		} else if (this.reconnectionAction){
			if ($debug) Debug.write("this.reconnectionAction: ", this.lastCalled);
			this.connect();
		} else {
			if (canvas.isRemoteUser() && (this.status == 'NetConnection.Connect.Closed' 
					|| this.status == 'NetConnection.Connect.NetworkChange'))
			{
				if (null != canvas.REDIRECT_URL_FOR_EXTERNAL_USERS) {
					new lz.redirectBox(canvas, {
							redirectURL:canvas.REDIRECT_URL_FOR_EXTERNAL_USERS
							, maxTime: 0
						});
				}
				this.counterror = 6; //NO more reconnects
			}
			this.useRTMPT = true
			var src = getUrl();
			this.setAttribute('src',src);
			//Debug.write("new src ",this.src);
			if (this.counterror < 3) {
				this.counterror++;
				if (canvas.thishib.loaderVar != null) {
					canvas.thishib.loaderVar.error.setAttribute('text',"try "+this.counterror);
				}
				if ($debug) Debug.write("Reconnecting: ", this.counterror);
				this.connect();
			} else {
				//Debug.write("connection failed");
				if (canvas.thishib.loaderVar != null) {
					canvas.thishib.loaderVar.error.setAttribute('text',this.status);
				}
				canvas.setAttribute('loadingmessage','connection failed');
				new lz.labelerrorPopup(canvas,{errorlabelid:556});
			}
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar._src.setAttribute('text',src);
			}
		}
	]]>
	</handler>	
	
	<method name="refreshSessionMeth" args="calleeObj">
		this.refreshSession.doCall();
	</method>
	
	<!-- This Function is just for refreshing the Session -->
	<netRemoteCallHib name="refreshSession" funcname="userservice.refreshSession" showLoading="false" >	
		<netparam><method name="getValue">return canvas.sessionId;</method></netparam>   
		<handler name="ondata" args="value">
			//if ($debug) Debug.write("hibRtmpConnection/refreshSession [",value,"]");
			lz.Timer.addTimer(parent.refreshDelegate, canvas.refreshSession);
		</handler>
	</netRemoteCallHib>
	  
	<netRemoteCallHib name="getsessiondata" funcname="xmlcrm.getsessiondata" >	  
		<handler name="ondata" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("hibRtmpConnection/getsessiondata [",value,"]");
			canvas.sessionObject = value;
			canvas.sessionId = value.sessionId;
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.setProgress();
			}
			parent.getPublicSID.doCall();
		</handler>  
	</netRemoteCallHib>
	 
	<netRemoteCallHib name="getPublicSID" funcname="getPublicSID" >	  
		<handler name="ondata" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("hibRtmpConnection/getPublicSID [",value,"]");
			canvas.publicSID = value;	 
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.setProgress();
			}
			parent.getDefaultLanguage.doCall();
		</handler>  
	</netRemoteCallHib>
	
	<netRemoteCallHib name="overwritePublicSID" funcname="overwritePublicSID" >	 
		<netparam><method name="getValue"> return canvas.publicSID;</method></netparam>
		<handler name="ondata" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("overwritePublicSID: ",value);
		</handler>  
	</netRemoteCallHib>	
	
	<method name="setDefaultUserLanguage">
		<![CDATA[
			if (userlang == -1 && canvas.language_id != 0) {
				userlang = canvas.language_id;
			} else if (userlang == -1) {
				userlang = canvas.default_lang_id;
			}
		]]>
	</method>
	
	<netRemoteCallHib name="setUsernameReconnect" funcname="setUsernameReconnect" remotecontext="$once{ canvas.thishib }" >   
		<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
		<netparam><method name="getValue">return canvas.userId;</method></netparam>
		<netparam><method name="getValue">return canvas.currentuser;</method></netparam>
		<netparam><method name="getValue">return canvas.firstName;</method></netparam>
		<netparam><method name="getValue">return canvas.lastName;</method></netparam>   
		<netparam><method name="getValue">return canvas.picture_uri;</method></netparam>   
		<handler name="ondata" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("setUsernameReconnect: ",canvas.userId,value);   
			parent.reconnectComplete();
		</handler>  
	</netRemoteCallHib>	
		
	<netRemoteCallHib name="getDefaultLanguage" funcname="languageservice.getDefaultLanguage" >	  
		<handler name="ondata" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			canvas.default_lang_id = value;
			if ($debug) Debug.write("getDefaultLanguage: ",value,"; canvas.lang = ", canvas.language_id);
			if (canvas.language_id==0){
				parent.userlang = canvas.default_lang_id;
			} else {
				parent.userlang = canvas.language_id;
			}
			parent.getLanguageByIdAndMax.doCall();
		</handler>  
	</netRemoteCallHib>	  
	
	<netRemoteCallHib name="getInvitationByHash" activeErrorHandler="true" funcname="invitationservice.getInvitationByHash">
		<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
		<netparam name="invitationHash"><method name="getValue">return canvas.invitationHash;</method></netparam>
		<handler name="ondata" args="value">
		<![CDATA[
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.close();
			}
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("getInvitationByHash: ",value);
			if (value<0){
			} else {
				if (value.allowEntry) {
					parent.currentInvitation = value;
					new lz.invitationQuickLoader(canvas.main_content._content.inner);
				} else {
					var addInfo = "" + value.validFrom +"<br/> - <br/>"+ value.validTo;
					var dlg = new lz.rpcErrorDialog(canvas,{errorid:-50,addInfo:addInfo});
				}
			}
		]]>
		</handler>
	</netRemoteCallHib> 
	
	<netRemoteCallHib name="secureLoginByRemote" activeErrorHandler="true" funcname="xmlcrm.secureLoginByRemote" >
		<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
		<netparam name="remoteSessionId"><method name="getValue">return canvas.secureHash;</method></netparam>
		<handler name="ondata" args="value">
		<![CDATA[
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.close();
			}
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("secureLoginByRemote: ",value);
			if (value < 0) {
			} else {
				if (value == null) {
					new lz.errorPopup(canvas,{error:'Invalid Hash'});
					return;
				}
				
				canvas.showNickNameDialog = value.showNickNameDialog;
				if ($debug) Debug.write("secureLoginByRemote1: ",canvas.showNickNameDialog);
				
				canvas.initroomid = value.roomId;
				canvas.becomemoderator = value.becomemoderator;
				canvas.showAudioVideoTest = value.showAudioVideoTest;
				
				canvas.roomRecordingId = value.roomRecordingId;
				
				if (canvas.roomRecordingId == null) {
					canvas.roomRecordingId = 0;
				}
				
				if (canvas.showNickNameDialog) {
					new lz.chooseNickName(canvas);
				} else {
					parent.getCurrentRoomClient.doCall();
				}
			}
		]]>
		</handler>
	</netRemoteCallHib>  
	
	<netRemoteCallHib name="loginUserByRemote" activeErrorHandler="true" 
		funcname="xmlcrm.loginUserByRemote" >		  
		<netparam name="remoteSessionId"><method name="getValue">return canvas.remoteUserSid;</method></netparam>
		<handler name="ondata" args="value">
			<![CDATA[
				
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) Debug.write("loginUserByRemote -1-: ",value);
				if ($debug) Debug.write("loginUserByRemote -2-: ",canvas.remoteUserSid);
				if (value<0){
					
				} else {
					parent.getCurrentRoomClient.doCall();
				}
			]]>
		</handler>   
	</netRemoteCallHib>  
	
	<netRemoteCallHib name="getCurrentRoomClient" funcname="xmlcrm.getCurrentRoomClient" >
		<netparam name="sessionId"><method name="getValue">return canvas.sessionId;</method></netparam>
		<handler name="ondata" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("getCurrentRoomClient: ", value);
			if (value != null) {
				canvas.currentClient = value;
				canvas.setAttribute('currentuser', value.firstname+" "+value.lastname);
				
				//Somehow this leads to a bug in the implementation of the secure User Login
				canvas.setAttribute('userId', value.userId);
				
				canvas.setAttribute('allowRecording', value.allowRecording);
				
				var fName = value.firstname == null ? "" : value.firstname;
				var lName = value.lastname == null ? "" : value.lastname;
				canvas.setAttribute('firstName', fName);
				canvas.setAttribute('lastName', lName);
				canvas.setAttribute('mail', value.email);
				
				if (canvas.isRemoteUser() && !fName && !lName) {
					if ($debug) Debug.write("!!!!!!!!!!! Nickname HIB ", value.email);
					new lz.chooseNickName(canvas);
				}
				hib.userobject.id = value.userId;
				hib.userobject.firstname = fName;
				hib.userobject.lastname = lName;
				
				canvas.setAttribute('lastLogin','');
				canvas.setAttribute('picture_uri', value.picture_uri);
				canvas.setAttribute('language','');
				
				if (canvas.wicketroomid > 0) {
					canvas.initroomid = canvas.wicketroomid;
				} else {
					if (canvas.thishib.loaderVar != null) {
						canvas.thishib.loaderVar.close();
					}
				}
				parent.getRoomById.doCall();
			}
			if ($debug) Debug.write("getCurrentRoomClient: ", canvas.currentClient);
		]]>
		</handler>
	</netRemoteCallHib>
	
	<netRemoteCallHib name="getRoomById" funcname="conferenceservice.getRoomById" >		  
		<netparam name="sessionId"><method name="getValue">return canvas.sessionId;</method></netparam>
		<netparam name="roomId"><method name="getValue">return canvas.initroomid;</method></netparam>
		<handler name="ondata" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("getRoomById: ",value);
			if (value!=null){
				if (canvas.wicketsid != null) {
					canvas.thishib.loaderVar.close();
				}
				if (canvas.directUserLogin) {
					canvas.directRoomObj = value;
					canvas.thishib.loaderVar.close();
				} else {
					canvas.setRoomValues(value);
				}
			} else {
				new lz.labelerrorPopup(canvas,{errorlabelid:1286});
			}
		]]>
		</handler>
	</netRemoteCallHib>
		
	<netRemoteCallHib name="getLanguageByIdAndMax" funcname="languageservice.getLanguageByIdAndMax" >
		<attribute name="start" value="0" type="number" />
		<attribute name="step" value="100" type="number" />
		<attribute name="max" value="1607" type="number" />
		<netparam><method name="getValue">return parent.parent.userlang;</method></netparam> 
		<netparam><method name="getValue">return parent.start;</method></netparam> 
		<netparam><method name="getValue">return parent.step;</method></netparam> 
		<handler name="ondata" args="value">
			<![CDATA[
			if($debug) Debug.write("hibRtmpConnection/userlang:[",parent.userlang,"]");
				//if($debug) Debug.write("hibRtmpConnection/getLanguageByIdAndMax:[",value,"]");
				setLabelObjectByHundred(this.start,value);
				//The onResult-Handler will be called be the rtmpconnection
				if (this.start <= max){
					this.start += this.step;
					if (canvas.thishib.loaderVar != null) {
					   canvas.thishib.loaderVar.setProgress();
					}
					this.doCall();
				} else {
					if($debug) Debug.write("loading lang complete");
					if (parent.initlanguageLoaded){
						if (canvas.thishib.loaderVar != null) {
							canvas.thishib.loaderVar.setProgress();
						}
						parent.setUsernameAndSession.doCall();
					} else {
						parent.initlanguageLoaded = true;
						if($debug) Debug.write("getGeneralOptions");
						parent.getGeneralOptions.doCall();
					}
				}
			]]>
		</handler>  
	</netRemoteCallHib>
		
	<method name="setUser" args="user">
		if (!user) {
			new lz.errorPopup(canvas,{error:"Missing User Object"});
		}
		hib.userobject = user;
		canvas.userId = hib.userobject.id;
	</method>
	
	<netRemoteCallHib name="getGeneralOptions" funcname="xmlcrm.getGeneralOptions">
		<handler name="ondata" args="value">
		<![CDATA[
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.setProgress();
			}
			if ($debug) Debug.write("getGeneralOptions: ", value.length, value);
			if (value != null) {
				if (value.length > 0 && value[0] != null) {
					//if ($debug) Debug.write("Give exclusive audio keycode is: ", value[0].value);
					canvas.setAttribute('GIVE_EXCLUSIVE_AUDIO_KEY', value[0].value);
				}
				if (value.length > 1 && value[1] != null) {
					if ($debug) Debug.write("red5sip.enable is: ", value[1].value);
					canvas.setAttribute('RED5_SIP_ENABLE', value[1].value);
				}
				if (value.length > 2 && value[2] != null) {
					if ($debug) Debug.write("max_upload_size is: ", value[2].value);
					canvas.setAttribute('MAX_UPLOAD_SIZE', value[2].value);
				}
				if (value.length > 3 && value[3] != null) {
					if ($debug) Debug.write("Mute/unmute keycode is: ", value[3].value);
					canvas.setAttribute('MUTE_AUDIO_KEY', value[3].value);
				}
				if (value.length > 4 && value[4] != null) {
					if ($debug) Debug.write("redirect.url.for.external.users is: ", value[4].value);
					canvas.setAttribute('REDIRECT_URL_FOR_EXTERNAL_USERS', value[4].value);
				}
			} else {
				if ($debug) Debug.warn("xmlcrm.getGeneralOptions empty!");
			}
			if (canvas.wicketsid != null) {
				parent.loginWicket.doCall();
			} else { 
				if (canvas.thishib.loaderVar != null) {
					canvas.thishib.loaderVar.close();
				}
				//do not show loggin-PopUp for the test-Application
				if (parent.testAppLoading){ 
					canvas.loadNextStepTestApp();
				} else if (!!canvas.invitationHash) {
					parent.getInvitationByHash.doCall();   
				} else if (canvas.secureRemoteUserLogin) {
					if ($debug) Debug.write("secureLoginByRemote:: ",canvas.secureHash);
					hib.userobject = {};
					parent.secureLoginByRemote.doCall();
				}
			}
		]]>
		</handler>
	</netRemoteCallHib>
	
	<netRemoteCallHib name="loginWicket" funcname="xmlcrm.loginWicket" >
		<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
		<netparam><method name="getValue">return canvas.wicketsid;</method></netparam>
		<netparam><method name="getValue">return canvas.wicketroomid;</method></netparam>
		<handler name="ondata" args="value">
		<![CDATA[
			if ($debug) Debug.write("!!!!!!!!!!! loginWicket", value);
			if (value != null) {
				canvas.setAttribute('userId', value.id);
				canvas.setAttribute('firstName', value.firstname == null ? "" : value.firstname);
				canvas.setAttribute('lastName', value.lastname == null ? "" : value.lastname);
				canvas.setAttribute('mail','');
				canvas.setAttribute('lastLogin','');
				canvas.setAttribute('picture_uri','');
				canvas.setAttribute('language','');
				canvas.setAttribute('currentuser',value.login);
				if (value.timeZoneId != null) {
					canvas.timeZoneId = value.timeZoneId;
				}
				if (value.rights != null) {
					canvas.becomemoderator = value.rights.indexOf('Admin') > -1;
				}
				if ($debug) Debug.write("hibRtmpConnection::loginWicket -> canvas.becomemoderator", canvas.becomemoderator);
				if (value.sessionData == null) {
					if ($debug) Debug.write("No Language Found to assign");
					return;
				}
				hib.userobject = value;
				parent.getCurrentRoomClient.doCall();
			} else {
				new lz.labelerrorPopup(canvas, {errorlabelid: 1599});
			}
		]]>
		</handler>
	</netRemoteCallHib>
	
		<netRemoteCallHib name="setUsernameAndSession" funcname="setUsernameAndSession" remotecontext="$once{ canvas.thishib }" >   
			<netparam><method name="getValue"> return canvas.sessionId; </method></netparam> 
			<netparam><method name="getValue">return canvas.userId;</method></netparam>
			<netparam><method name="getValue">return canvas.currentuser;</method></netparam>
			<netparam><method name="getValue">return canvas.firstName;</method></netparam>
			<netparam><method name="getValue">return canvas.lastName;</method></netparam>	  
			<handler name="ondata" args="value">
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) Debug.write("setUsernameAndSession: ",canvas.userId,value);
				if (canvas.thishib.loaderVar != null) {
					canvas.thishib.loaderVar.close();
				}
			</handler>  
		</netRemoteCallHib>		
		
		<netRemoteCallHib name="testMethod" funcname="testMethod">
			<handler name="ondata" args="value">
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) Debug.write("testMethod ",value);				   
			</handler>  
		</netRemoteCallHib>

		<!--- Notification of new User --> 
		<method name="addNewUser" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("addNewUser: ",value);
			if(value.sipTransport) {
				canvas._videocontainer.addItem(value.connectedSince,value.isMod,value.streamid,value.roomId,'',value.formatedDate,value.userpos,value.usercolor,value);
			} else {
				canvas._videocontainer.addClientItem(value.connectedSince,value.isMod,value.streamid,value.roomId,'',value.formatedDate,value.userpos,value.usercolor,value);
			}
			canvas.setAttribute('numberofpartners',canvas.numberofpartners+1);
		</method>	
		
		<netRemoteCallHib name="getCurrentModeratorList" funcname="getCurrentModeratorList">
			<handler name="ondata" args="value">
				<![CDATA[
					if ($debug) Debug.write("############ getCurrentModeratorList: ",value);
					
					canvas.analyzeModerationList(value);
					
					canvas.currentModeratorList = value;
					//Update Moderation Flag
					canvas.updateModerationFlag();
					
					var messageAlreadyThrown = false;
					
					//if ($debug) Debug.write("throw event to drawarea: ", canvas.moderatorStreamID, canvas.ismoderator);
					
					if (this.parent.modus == "conference") {
						if ($debug) Debug.write("############## start broadcasting ");
						parent.setBroadCastingFlag.publicSIDOfNewModerator = canvas.publicSID;
						parent.setBroadCastingFlag.canVideo = !canvas.currentRoomObj.audioOnly;
						parent.setBroadCastingFlag.isAllowedToBroadCastAV = true;
						parent.setBroadCastingFlag.doCall();
					}
					canvas._drawarea.onopenWhiteBoard.sendEvent();
					
					if ($debug) Debug.write("room ", canvas.currentRoomObj);
					if ($debug) Debug.write("room.type ", canvas.currentRoomObj.type);
					
					if (canvas.currentRoomObj.type != 'restricted') {
						if (canvas.currentRoomObj.moderated) {
							if (value.length == 0 && !messageAlreadyThrown){
								new lz.labelerrorPopup(canvas,{errorlabelid:641});
							}
						} else {
							if (value.length == 0 && !messageAlreadyThrown){
								new lz.errorModeratorPopup(canvas,{error:canvas.getLabelName(498)});
							}
						}
					}
				]]>
			</handler>
		</netRemoteCallHib>
		
		<method name="newStream" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("newStream: ",value);
			if (value == null || value.screenClient) {
				return;
			}
			canvas.commonVideoViewContent.startStream(value);
		</method> 
		   
		<netRemoteCallHib name="closeStream" funcname="closeStream">
			<handler name="ondata" args="value">
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) Debug.write("**** closeStream: ",value);
				if (value == null) {
					return;
				}
				if (value.screenClient) {
					if ($debug) Debug.write(" ondata closeStream: ",value.streamPublishName); 
					canvas.commonVideoViewContent.closeScreenSharing(value);
				} else {
					//free the VideoContainer
					//canvas._videocontainer.closeStreamClient(value.publicSID);
					canvas.commonVideoViewContent.closeStreamClient(value.publicSID);
					canvas.setAttribute('numberofpartners',canvas.numberofpartners-1);
				}
				//TODO:check first current tab
			</handler>   
		</netRemoteCallHib>  
		
		<!---
			Event is invoked if a red5 stream sharing is closed
		 -->
		<method name="stopScreenSharingMessage" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("**** closeStream: ",value);
			if ($debug) Debug.write(" onResult stopScreenSharingMessage : ",value.streamPublishName);
			canvas.commonVideoViewContent.closeScreenSharing(value);
		</method> 
			 
		<netRemoteCallHib name="clientregisterRoom" funcname="clientregisterRoom">
			<handler name="ondata" args="value">
				if ($debug) Debug.write("**** clientregisterRoom::ondata ", value);
			</handler>   
		</netRemoteCallHib>   

		<method name="roomDisconnectUser" args="value,id">
			canvas._videocontainer.disconnectclient(id);
			if (canvas.commonVideoViewContent != null) {
				canvas.commonVideoViewContent.disconnectclient(id);
				if (canvas.currentModApply != null) canvas.currentModApply.rejectUser(value);
				if (value.isRecording) {
					canvas._mymod.recordingUser = null;
				}
				if (value.streamPublishStarted) {
					canvas._mymod.publishingObj = null;
				}
				canvas._mymod.setMessage();
			}
		</method>
		
		<method name="roomDisconnect" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("roomDisconnect: ", value);
			if (value == null || value.screenClient) {
				return;
			}
			if (canvas.currentBaseConferenceRoom != null && canvas.currentBaseConferenceRoom._chatPanelStrict != null) {
				if ($debug) Debug.write("canvas.currentBaseConferenceRoom._chatPanelStrict: ", canvas.currentBaseConferenceRoom._chatPanelStrict);
				canvas.currentBaseConferenceRoom._chatPanelStrict.closeprivatechat(["close", value.publicSID]);
			}
			if (!value.securityCode && canvas.currentActivityList != null) {
				canvas.currentActivityList.addMessageRequest(value, canvas.getLabelName(1367), new Date().getTime());
			}
			this.roomDisconnectUser(value, value.publicSID);
		]]>
		</method>
		
		<method name="stopRecordingMessage" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			canvas._mymod.recordingUser = null;
			canvas._mymod.setMessage();				 
		</method>
		
		<method name="stopPublishingMessage" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			canvas._mymod.publishingObj = null;
			canvas._mymod.setMessage();				 
		</method>
		
		<netRemoteCallHib name="setSyncFlag" funcname="setSyncFlag" >	  
			<handler name="ondata" args="value">
				if ($debug) Debug.write("setSyncFlag: ",value);
			</handler>
		</netRemoteCallHib>   
			 
		<netRemoteCallHib name="logicalRoomLeaveDis" funcname="logicalRoomLeaveDis" >	  
			<handler name="ondata" args="value">
				if ($debug) Debug.write("logicalRoomLeaveDis: ",value);
				parent.roomDisconnectUser(value, value.broadCastID);
			</handler>
		</netRemoteCallHib>			 
  
		<method name="setUserStatus" args="ctx,user,o">
			<![CDATA[
				if (!o || !user) return;
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) {
					Debug.write("setUserStatus: ", user);
					Debug.write("setUserStatus: ", o.param);
				}
				var aObj = o.param[3];
				var usPoint = null;
				if ($debug) Debug.write("drawObj: ", aObj[0]);
				switch(aObj[0]) {
					case 'line':
					case 'uline':
						usPoint = {x: aObj[aObj.length - 5] + aObj[6], y: aObj[aObj.length - 4] + aObj[7]};
						break;
					case 'letter':
					case 'rectangle':
					case 'ellipse':
					case 'clipart':
						usPoint = {x: aObj[aObj.length - 3] + aObj[aObj.length - 5], y: aObj[aObj.length - 2] + aObj[aObj.length - 4]};
						break;
					case 'paint':
						var points = aObj[1];
						//points are empty on 'paint' move
						usPoint = {
							x: aObj[aObj.length - 5] + (points.length ? points[points.length - 1][3] : aObj[aObj.length - 3])
							, y: aObj[aObj.length - 4] + (points.length ? points[points.length - 1][4] : aObj[aObj.length - 2])};
						break;
					case 'drawarrow':
						usPoint = {x: aObj[aObj.length - 5] + aObj[9], y: aObj[aObj.length - 4] + aObj[10]};
						break;
				}
				if (usPoint) {
					var us = new lz.userStatus(ctx, {
						width:100
						, x: usPoint.x
						, y: usPoint.y - 25 //little above
						, queueable: false
						, statusText: user.firstname + " " + user.lastname
						});
					if ($debug) Debug.write("us: ", us, "; usPoint: ", usPoint);
				}
			]]>
		</method>

		<method name="sendVarsToWhiteboardById" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("sendVarsToWhiteboardById : ", value);
			this.setUserStatus(canvas._drawarea, value[0], value[1]);
			canvas._drawarea.parent.parent.parent.sendWatchObjectByWhiteboard(value[1]);
		]]>
		</method> 
		
		<method name="loadWmlToWhiteboardById" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("loadWmlToWhiteboardById : ",value);
			canvas._drawarea.parent.parent.parent.loadWmlToWhiteboardById(value);
		]]>
		</method>
		
		<!--
			Adds this User to the List of current Moderators
		 -->
		<netRemoteCallHib name="addModerator" funcname="addModerator">
			<attribute name="publicSIDOfNewModerator" value="0" type="string" />
			<netparam name="vars"><method name="getValue">return parent.publicSIDOfNewModerator;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) Debug.write(" addModerator : ",value);				   
				]]>
			</handler>   
		</netRemoteCallHib>
		
		<netRemoteCallHib name="removeModerator" funcname="removeModerator">
			<attribute name="publicSIDOfNewModerator" value="0" type="string" />
			<netparam name="vars"><method name="getValue">return parent.publicSIDOfNewModerator;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				//Debug.write(" onResult setModerator : ",value);				   
				]]>
			</handler>   
		</netRemoteCallHib>
		
		<!--
		public synchronized Long setBroadCastingFlag(String publicSID, boolean value, boolean canVideo, Integer podId) 
		 -->
		<netRemoteCallHib name="setBroadCastingFlag" funcname="setBroadCastingFlag">
			<attribute name="publicSIDOfNewModerator" value="0" type="string" />
			<attribute name="isAllowedToBroadCastAV" value="false" type="boolean" />
			<attribute name="canVideo" value="false" type="boolean" />
			<attribute name="avsettings" value="av" type="string" />
			<attribute name="interviewPodId" value="0" type="number" />
			<netparam><method name="getValue">return parent.publicSIDOfNewModerator;</method></netparam>
			<netparam><method name="getValue">return parent.isAllowedToBroadCastAV;</method></netparam>
			<netparam><method name="getValue">return parent.canVideo;</method></netparam>
			<netparam><method name="getValue">return parent.interviewPodId;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				//Debug.write(" onResult setModerator : ",value);				   
				]]>
			</handler>   
		</netRemoteCallHib>
		
		<method name="setNewBroadCastingFlag" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write(" onResult setNewBroadCastingFlag : ", value);
			var u = canvas._videocontainer._participants.getUserListItemByPublicSID(value.publicSID);
			if (u != null) {
				u.update(value);
			}
			if (canvas.publicSID == value.publicSID) {
				canvas.commonVideoViewContent.toggleVideo(value.canVideo);
				canvas.setAttribute("isBroadCasting", value.isBroadcasting);
				canvas.setAttribute("canVideo", value.canVideo);
				
				if ($debug) Debug.write("Its about You ", value);
				if (value.isBroadcasting) {
					if (canvas.thishib.modus == "interview") {
						canvas._drawarea.newInterviewStarting(value);
					} else {
						canvas.commonVideoViewContent.createEditRecordStream(false, false, -1);
					}
				}
			}
			canvas.setAttribute("lastBroadCastingUser",value);
		]]>
		</method>

		<netRemoteCallHib name="giveExclusiveAudio" funcname="giveExclusiveAudio">
			<attribute name="publicSID" value="0" type="string" />
			<netparam><method name="getValue">return parent.publicSID;</method></netparam>
			<method name="setExclusiveAudio" args="tPublicSID">
				this.publicSID = tPublicSID;
				this.doCall();
			</method>
		</netRemoteCallHib>

		<method name="receiveExclusiveAudioFlag" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			canvas._videocontainer.receiveExclusiveAudioFlag(value.publicSID)
		]]>
		</method>

		<netRemoteCallHib name="switchMicMuted" funcname="switchMicMuted">
			<attribute name="publicSID" value="" type="string" />
			<attribute name="mute" value="false" type="boolean" />
			<event name="onMute" />
			<method name="setMute" args="tPublicSID,tMute">
				this.publicSID = tPublicSID;
				this.mute = tMute;
				var obj = new Array();
				obj["mute"] = tMute;
				obj["publicSID"] = tPublicSID;
				this.onMute.sendEvent(obj);
				this.doCall();
			</method>
			<netparam><method name="getValue">return parent.publicSID;</method></netparam>
			<netparam><method name="getValue">return parent.mute;</method></netparam>
		</netRemoteCallHib>

		<method name="newRed5ScreenCursor" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			//if ($debug) Debug.write(" onResult newRed5ScreenCursor : ",value);
			canvas.commonVideoViewContent.updateCursorScreenSharing(value);
		]]>
		</method>
		
		<!--
			Red5 Screen Sharing
		 -->
		<method name="newScreenSharing" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			//if ($debug) Debug.write(" onResult newScreenSharing 1 : ",value);
			//if ($debug) Debug.write(" onResult newScreenSharing 2 : ",value.streamid);
			//if ($debug) Debug.write(" onResult newScreenSharing 3 : ",canvas.streamid);
			if ($debug) Debug.write(" onResult newScreenSharing 4 : ",value.streamPublishName);
			if ($debug) Debug.write(" onResult newcreenSharing 5 : ",canvas.publicSID);
			
			canvas.commonVideoViewContent.newScreenSharing(value);
		]]>
		</method>
		
		<netRemoteCallHib name="checkScreenSharing" funcname="checkScreenSharing">
			<handler name="ondata" args="value">
			<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) Debug.write(" onResult checkScreenSharing : ",value);  
				if (value != null) {
					canvas.commonVideoViewContent.newScreenSharings(value);
				} else {
					if ($debug) Debug.warn("Self Screen Sharing");
				}
			]]>
			</handler>   
		</netRemoteCallHib>
		
		<!--
		public synchronized Long applyForModeration(String publicSID)
		 -->
		<netRemoteCallHib name="applyForModeration" funcname="applyForModeration"
					   remotecontext="$once{ canvas.thishib }">
			<netparam><method name="getValue">return canvas.publicSID;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
					//The onResult-Handler will be called be the rtmpconnection
					if ($debug) Debug.write("applyForModeration : ",value);
					if (value == 1) {
						//Do add direct
						parent.addModerator.publicSIDOfNewModerator = canvas.publicSID;
						parent.addModerator.doCall();
					} else if (value == 2) {
						//Ask the Moderator
						var tDate = new Date();
						parent.sendMessageWithClient.sendMessage("applyForModeration",tDate.getTime());
					} else if (value == 3) {
						new lz.labelerrorPopup(canvas,{errorlabelid:696});
					}
				]]>
			</handler>
		</netRemoteCallHib>
		
		<netRemoteCallHib name="setCanDraw" funcname="whiteboardservice.setCanDraw"
					   remotecontext="$once{ canvas.thishib }">
			<attribute name="publicSID" value="" type="string" />
			<attribute name="canDraw" value="true" type="boolean" />
			<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
			<netparam><method name="getValue">return parent.publicSID;</method></netparam>
			<netparam><method name="getValue">return parent.canDraw;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
					//The onResult-Handler will be called be the rtmpconnection
					if ($debug) Debug.write("setCanDraw : ",value);
				]]>
			</handler>   
		</netRemoteCallHib>
		
		<netRemoteCallHib name="setCanShare" funcname="whiteboardservice.setCanShare"
					   remotecontext="$once{ canvas.thishib }">
			<attribute name="publicSID" value="" type="string" />
			<attribute name="canShare" value="true" type="boolean" />
			<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
			<netparam><method name="getValue">return parent.publicSID;</method></netparam>
			<netparam><method name="getValue">return parent.canShare;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
					//The onResult-Handler will be called be the rtmpconnection
					if ($debug) Debug.write("setCanShare : ",value);
				]]>
			</handler>   
		</netRemoteCallHib>
		
		<netRemoteCallHib name="setCanRemote" funcname="whiteboardservice.setCanRemote"
					   remotecontext="$once{ canvas.thishib }">
			<attribute name="publicSID" value="" type="string" />
			<attribute name="canRemote" value="true" type="boolean" />
			<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
			<netparam><method name="getValue">return parent.publicSID;</method></netparam>
			<netparam><method name="getValue">return parent.canRemote;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
					//The onResult-Handler will be called be the rtmpconnection
					if ($debug) Debug.write("setCanRemote : ",value);
				]]>
			</handler>   
		</netRemoteCallHib>
		
		<method name="setNewModeratorByList" args="value">
		<![CDATA[
			if ($debug) Debug.write("setNewModeratorByList ",value);
			canvas.analyzeModerationList(value);
			
			//The onResult-Handler will be called be the rtmpconnection
			canvas.currentModeratorList = value;
			//Update Moderation Flag
			canvas.updateModerationFlag();
		]]>
		</method> 
		
		<netRemoteCallHib name="sendMessage" funcname="sendMessage">
			<netparam name="vars"><method name="getValue">return canvas.objMessage;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				//Debug.write("getValue : ",value);
				
				]]>
			</handler>   
		</netRemoteCallHib> 
		
		<netRemoteCallHib name="sendMessageAll" funcname="sendMessageAll">
			<netparam name="vars"><method name="getValue">return canvas.objMessage;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				//Debug.write("getValue : ",value);
				]]>
			</handler>   
		</netRemoteCallHib> 
		
		<method name="sendVarsToMessage" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			//Debug.write("sendVarsToMessage : ",value);
			if (value[0]=='audioActivity'){
				//canvas.currentModApply
				//if ($debug) Debug.write("audioActivity Client ",value[1],value[2]);
				canvas._videocontainer.setSpeakingByPos(value[2],value[1]);
			} else if (value[0]=='typingActivity'){
				if ($debug) Debug.write("!!!typingActivity ::", value[1], canvas._videocontainer._participants.getUserListItemByPublicSID(value[2]));
				canvas._videocontainer._participants.getUserListItemByPublicSID(value[2]).userTyping(value[1]);
			} else if (value[0]=='chat'){
				// Not Used
				//Debug.warn("Not Used");
				canvas.addChatHistory(value);
			} else if (value[0]=='activateWhiteboard'){
				// Not Used
				//Debug.warn("Not Used");
				canvas._drawarea.parent.parent.parent.activateWhiteboard(value);
			} else if (value[0]=='newWhiteboard'){
				// Not Used
				//Debug.warn("Not Used");
				canvas._drawarea.parent.parent.parent.newWhiteboard(value);
			} else if (value[0]=='removeWindow'){
				// Not Used
				//Debug.warn("Not Used");
				canvas._drawarea.parent.parent.parent.removeWindow(value);
			} else if(value[0]=='fileslist'){
				canvas.currentImagesListdraw.parent.onvisible.sendEvent(true);
			}
		]]>
		</method>
		   
		<netRemoteCallHib name="sendVarsModeratorGeneral" funcname="sendVarsModeratorGeneral">
			<netparam name="vars"><method name="getValue">return canvas.VarsModeratorGeneral;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				//Debug.write("sendVarsModeratorGeneral : ",value);
				
				]]>
			</handler>   
		</netRemoteCallHib>  

		<netRemoteCallHib name="sendChatMessageWithClient"
			funcname="chatservice.sendMessageWithClient" remotecontext="$once{ canvas.thishib }">
			<attribute name="messageObj" value="null" />
			<netparam><method name="getValue">return parent.messageObj;</method></netparam>

			<method name="sendMessage" args="messageObject">
				this.messageObj = messageObject;
				this.doCall();
			</method>
			<handler name="ondata" args="value">
				<![CDATA[
					//The onResult-Handler will be called be the rtmpconnection
					if ($debug) Debug.write("chatservice.sendMessageWithClient getValue : ",value);
				]]>
			</handler>
		</netRemoteCallHib>
		
		<netRemoteCallHib name="sendMessageWithClient" funcname="sendMessageWithClient" 
						  remotecontext="$once{ canvas.thishib }" >  
			
			<attribute name="messageObj" value="null" />
			<method name="sendMessage" args="typeName,messageObject">
				this.messageObj = new Object();
				this.messageObj[0] = typeName;
				this.messageObj[1] = messageObject;
				this.doCall();
			</method>
			
			<method name="sendAdvMessage" args="typeName,messageObject,tStamp">
				this.messageObj = new Object();
				this.messageObj[0] = typeName;
				this.messageObj[1] = messageObject;
				this.messageObj[2] = tStamp;
				this.doCall();
			</method>
			
			<netparam name="vars"><method name="getValue">return parent.messageObj;</method></netparam>
			<handler name="ondata" args="value">
				//The onResult-Handler will be called be the rtmpconnection
				//Debug.write("sendMessageWithClient : ",value);
			</handler>
		</netRemoteCallHib>
		  
		<method name="sendVarsToMessageWithClient" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("sendVarsToMessageWithClient : ", value,value.message, value.message[0]);
			if (value[0] == 'kick' || value.message[0] == 'kick') {
				if ($debug) Debug.write("!!!!!! THIS USER GOING TO BE KICKED");
				this.showKickMessage = true;
				this.disconnect();
			} else if (value.message[0]=='copiedText'){
				//canvas.currentModApply
				
				if ($debug) Debug.info("copiedText :: ",value.message[1]);
				//System.setClipboard(value.message[1]);
				//lz.Browser.setClipboard(value.message[1]);
				//LzBrowserKernel.setClipboard (value.message[1]);
				//import flash.System;
				//flash.System.setClipboard(value.message[1]);
				
				new lz.copiedTextPopup(canvas,{error:value.message[1]});
			} else if (value.message[0]=='applyforMod'){
				//canvas.currentModApply
				if (canvas.streamid!=value.client.streamid) {
					new lz.responseForModeration(canvas.main_content._content.inner,{
							userobject:value.client,
							clientId:value.client.streamid
						});
				}
			} else if (value.message[0]=='applyModAnswer'){
				canvas.currentModApply.setUserAnswer(value);
			} else if (value.message[0]=='privatechat'){
				if ($debug) Debug.write("privatechat",value.message,value.client);
				canvas._currentChatPanel.privatechat(value.message,value.client);
			} else if (value.message[0]=='chat'){
				if (canvas._chatcontent) canvas._chatcontent.addChatHistory(value.message,value.client);
			} else if (value.message[0]=='avsettings'){
				canvas.commonVideoViewContent.setAVSettingsToClient(value.client);
			} else if (value.message[0]=='whiteboard'){
				//if (value.message[1]=='wmlloadcomplete'){
				//	canvas._drawarea.sendCompleteWmlLoadedRClient(value.client);
				//} else if (value.message[1]=='wmlsynccomplete'){
				//	canvas._drawarea.sendCompleteWmlSync(value.client);
				//} else
				if (value.message[1]=='imageloadcomplete'){
					canvas._drawarea.sendCompleteImageLoadedRClient(value.client);
				} else if (value.message[1]=='imagesynccomplete'){
					canvas._drawarea.sendCompleteImageSync(value.client);
				} else if (value.message[1]=='imageloaderror'){
					canvas._drawarea.sendCompleteImageLoadedRClient(value.client);
				} else if (value.message[1]=='imageloadtimeout'){
					canvas._drawarea.sendCompleteImageLoadedRClient(value.client);
				} else if (value.message[1]=='swfloadcomplete'){
					canvas._drawarea.sendCompleteSWFLoadedRClient(value.client);
				} else if (value.message[1]=='swfsynccomplete'){
					canvas._drawarea.sendCompleteSWFSync(value.client);
				} else if (value.message[1]=='swfloaderror'){
					canvas._drawarea.sendCompleteSWFLoadedRClient(value.client);
				} else if (value.message[1]=='swfloadtimeout'){
					canvas._drawarea.sendCompleteSWFLoadedRClient(value.client);
				} else if (value.message[1]=='inituser'){
					//this message is deprecated and can be removed!
					//swagner 12.06.2008
					//canvas._drawarea.sendCompleteImageSync(value.client);
					if ($debug) Debug.write("inituser loadwmlObjectToStage: ",value.message[2]);
					if (!canvas.ismoderator) canvas._drawarea.loadwmlObjectToStage(value.message[2],"","","",true,true);
				} else if (value.message[1]=='initgetVars'){
					//canvas._drawarea.sendCompleteImageSync(value.client);
					//Debug.write("initgetVars sendVarsToMessageWithClient: ",value.message[2]);
					canvas._drawarea.sendWatchObject(value.message[1],value.message[2],false);
				} else if (value.message[1]=='syncinitLoader'){
					//canvas._drawarea.sendCompleteImageSync(value.client);
					//Debug.write("syncinitLoader sendVarsToMessageWithClient: ",value.message[2]);
					if (value.client.streamid!=canvas.streamid) canvas._drawarea.remoteSyncLoader();
				} else if (value.message[1][0]=='isSnapToGrid'){
					canvas._drawarea.setAttribute('isSnapToGrid', value.message[1][1]);
					//Debug.write("syncinitLoader sendVarsToMessageWithClient: ",value.message[2]);
					//if (value.client.streamid!=canvas.streamid) canvas._drawarea.remoteSyncLoader();
				}
			} else if (value.message[0]=='updateMuteStatus'){
				canvas.setMuteStatus(value.message[1]);
			} else if (value.message[0]=='updateDrawStatus'){
				canvas.setDrawAllowStatus(value.message[1]);
				//Notify all Listeners for change of the item
				canvas.setAttribute("drawAllowStatus",value.message[1]);
			} else if (value.message[0]=='updateGiveAudioStatus') {
				canvas.setExclusiveAudioAllowStatus(value.message[1]);
				canvas.setAttribute("exclusiveAudioAllowStatus",value.message[1]);
			} else if (value.message[0]=='applyForModeration'){
				if ($debug) Debug.write("Somebody wants the Moderation ",value.client);
				canvas.currentActivityList.addModerationRequest(value.client,value.message[1]);
			} else if (value.message[0]=='applyForScreen'){
				if ($debug) Debug.write("Somebody wants to share/record Screen ",value.client);
				canvas.currentActivityList.addScreenRequest(value.client,value.message[1]);
			} else if (value.message[0]=='applyForRemote'){
				if ($debug) Debug.write("Somebody wants to remote control screen ",value.client);
				canvas.currentActivityList.addRemoteRequest(value.client,value.message[1]);
			} else if (value.message[0]=='applyForWhiteboard'){
				if ($debug) Debug.write("Somebody wants to draw on Whiteboard ",value.client);
				canvas.currentActivityList.addWhiteboardRequest(value.client,value.message[1]);
			} else if (value.message[0]=='applyForA'){
				if ($debug) Debug.write("Somebody wants to share A ",value.client);
				canvas.currentActivityList.addAudioRequest(value.client,value.message[1]);
			} else if (value.message[0]=='applyForAV'){
				if ($debug) Debug.write("Somebody wants to share AV ",value.client);
				canvas.currentActivityList.addAudioAndVideoRequest(value.client,value.message[1]);
			} else if (value.message[0]=='hideActivityObj'){
				if ($debug) Debug.write("Somebody wants to hideActivityObj ",value.client);
				canvas.currentActivityList.hideActivityObj(value);
			} else if (value.message[0]=='applyForMuteOn'){
				canvas.currentActivityList.applyForMuteOn(value.client,value.message[1]);
			} else if (value.message[0]=='applyForMuteOff'){
				canvas.currentActivityList.applyForMuteOff(value.client,value.message[1]);
			} else if (value.message[0]=='applyForGiveExclusiveAudioOn'){
				canvas.currentActivityList.applyForGiveExclusiveAudioOn(value.client,value.message[1]);
			} else if (value.message[0] == 'personal') {
				var pSID = value.client.publicSID;
				var vo = canvas._videocontainer._participants.getUserListItemByPublicSID(pSID);
				if (vo != null) {
					vo.setAttribute('lastname', value.message[2]);
					vo.refObj.lastname = value.message[2];
				}
				canvas.commonVideoViewContent.updateFirstLastName(pSID, value.message[1], value.message[2]);
			} else {
				if ($debug) Debug.warn("sendVarsToMessageWithClient unkown message ",value);
			}
		]]>
		</method>	 
	
		<method name="newMessageByRoomAndDomain" args="value">
		<![CDATA[
			if (value[0]=='closeprivatechat'){
				if ($debug) Debug.write("closeprivatechat",value);
				canvas._currentChatPanel.closeprivatechat(value);
			} else if (value[0]=='newprivatechat'){
				if ($debug) Debug.write("newprivatechat",value);
				canvas._currentChatPanel.newprivatechat(value);
			} else if (value.message=='desktop'){
				canvas._drawarea.incomingScreenSharing(value);
			} else if (value.message=='library'){
				if (value.action == 'import') {
					canvas.currentUploadWindow.remoteComplete(value);
					return;
				}
			} else if (value.message=='startStreaming'){
				canvas._drawarea.startStreaming(value);
			} else if (value.message=='stopStreaming'){
				canvas._drawarea.stopStreaming(value);
			} else if (value.message=='roomClosed'){
				canvas.roomClosed();
			} else {
				if ($debug) Debug.warn("Unknown Event -newMessageByRoomAndDomain- ",value);
			}
		]]>
		</method>	  
			   
	<method name="newPoll" args="value">
	<![CDATA[
		//The onResult-Handler will be called by the rtmpconnection
		if ($debug) Debug.write("newPoll : ", value);
		if (canvas.userId != value.creator.id) {
			ExternalInterface.call("vote", canvas.publicSID);
		}
	]]>
	</method>					
								
		<method name="sendVarsToModeratorGeneral" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			//Debug.write("sendVarsToModeratorGeneral : ",value);
			if (value[0]=='sharewhiteinit'){
				if (!canvas.htmlframeisloaded){
					canvas.ifrm.createIFrame();
					canvas.setAttribute('htmlframeisloaded',true);
				}
			}
		]]>
		</method>	   
		
	<method name="startedRecording" args="value">
		if ($debug) Debug.write("startedRecording: ",value);
		canvas._mymod.recordingUser = value;
		canvas._mymod.setMessage();
	</method>
	
	<netRemoteCallHib name="checkLzRecording" funcname="recordingservice.checkLzRecording" >	  
		<handler name="ondata" args="value">
			if ($debug) Debug.write("checkLzRecording: ",value);
			if (value != null) {
				canvas._mymod.recordingUser = value;
				canvas._mymod.setMessage();
			}
			parent.checkScreenSharing.doCall();
		</handler>
	</netRemoteCallHib>
	
	<method name="startedPublishing" args="value">
		if ($debug) Debug.write("startedPublishing: ", value);
		canvas._mymod.publishingObj = {user: value[0], url: value[1]};
		canvas._mymod.setMessage();
	</method>
	
	<method name="roomConnect" args="value">
		if ($debug) Debug.write("roomConnect: ",value);
		canvas._videocontainer.addItem(value.connectedSince,value.isMod,value.streamid,value.username,
				'',value.formatedDate,value.userpos,value.usercolor,value);
	</method>
	
	<method name="nickNameSet" args="value">
		if ($debug) Debug.write("nickNameSet: ", value);
		canvas.currentClient = value;
		canvas.setAttribute('mail', value.email);
		canvas.setAttribute('firstName', value.firstname);
		canvas.setAttribute('lastName', value.lastname);
		var v = canvas.commonVideoViewContent.getVideoObjectByPublicSID(value.publicSID);
		if (v != null) {
			v.setAttribute('chatpartnername', canvas.currentClient.firstname + ' ' + canvas.currentClient.lastname);
		}
		if (canvas._videocontainer) {
			var vo = canvas._videocontainer._participants.getUserListItemByPublicSID(value.publicSID);
			if (vo != null) {
				vo.update(value);
			}
		}
	</method>
	
	<!-- Whiteboard sync Events -->
	<method name="sendSyncFlag" args="value">
	<![CDATA[
		//The onResult-Handler will be called be the rtmpconnection
		if ($debug) Debug.write("sendSyncFlag: ",value);
		if (canvas.syncWindow == null) {
			canvas.syncWindow = new lz.syncWin(canvas.main_content._content.inner, {labelid: 558, labeliderror: 559});
		}
	]]>
	</method>	 
	
	<method name="sendSyncCompleteFlag" args="value">
	<![CDATA[
		//The onResult-Handler will be called be the rtmpconnection
		if ($debug) Debug.write("sendSyncCompleteFlag: ",value);
		if (canvas.syncWindow != null) {
			canvas.syncWindow.close();
			canvas.syncWindow = null;
		}
	]]>
	</method>  
	
	<!-- Whiteboard Object Sync Process -->
	<method name="sendObjectSyncFlag" args="value">
	<![CDATA[
		//The onResult-Handler will be called be the rtmpconnection
		if ($debug) Debug.write("sendObjectSyncFlag: ",value);
		if (canvas.syncImageWindow == null) {
			canvas.syncImageWindow = new lz.syncWin(canvas.main_content._content.inner, {labeliderror: 591});
		}
	]]>
	</method>	 
	
	<method name="sendObjectSyncCompleteFlag" args="value">
	<![CDATA[
		//The onResult-Handler will be called be the rtmpconnection
		if ($debug) Debug.write("sendObjectSyncCompleteFlag: ",value);
		if (canvas.syncImageWindow != null) {
			canvas.syncImageWindow.close();
			canvas.syncImageWindow = null;
		}
	]]>
	</method>  
	
	<!-- Recording of Meetings -->
	<method name="interviewStatus" args="value">
	<![CDATA[
		//The onResult-Handler will be called be the rtmpconnection
		if ($debug) Debug.write("interviewStatus: ",value);
		canvas._drawarea.reloadStatus();
	]]>
	</method>  
	
	<method name="clearChatContent" args="value">
	<![CDATA[
		//The onResult-Handler will be called be the rtmpconnection
		canvas._chatcontent.reload();
	]]>
	</method> 
	
	<netRemoteCallHib name="setCanGiveAudio" funcname="whiteboardservice.setCanGiveAudio"
				   remotecontext="$once{ canvas.thishib }">
		<attribute name="publicSID" value="" type="string" />
		<attribute name="canGiveAudio" value="true" type="boolean" />
		<method name="sendValue" args="publicSID,giveAudio">
			this.publicSID = publicSID;
			this.canGiveAudio = giveAudio;
			this.doCall();
		</method>
		<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
		<netparam><method name="getValue">return parent.publicSID;</method></netparam>
		<netparam><method name="getValue">return parent.canGiveAudio;</method></netparam>
		<handler name="ondata" args="value">
			<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) Debug.write("setCanGiveAudio : ",value);
			]]>
		</handler>
	</netRemoteCallHib>
</class>

<hibRtmpConnection name="thishib" id="hib" />

</library>
