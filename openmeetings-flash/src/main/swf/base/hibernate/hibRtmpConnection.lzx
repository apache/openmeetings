<?xml version="1.0" encoding="UTF-8" ?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at
  
	  http://www.apache.org/licenses/LICENSE-2.0
		  
  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
  
-->
<library>
	
<class name="userStatus" extends="view" width="250" height="30">
	<attribute name="statusText" type="string" />
	<attribute name="statusColor" type="number" value="0" />

	<text name="status" width="240" height="20" x="5" y="5" fontstyle="bold" fgcolor="0" text="defaulttext" fontsize="10"/>

	<handler name="oninit">
		this.status.setAttribute("text", this.statusText);
		this.status.setAttribute("fgcolor", this.statusColor);
		this.setAttribute("visibility", "visible");
		lz.Timer.addTimer( new LzDelegate( this, "selfDestroy" ), 3000 );
	</handler>

	<method name="selfDestroy" args="ignore=null">
		this.destroy();
	</method>
</class>

<class name="hibRtmpConnection" extends="rtmpConnection" debug="false" src="$once{ this.getUrl() }" >
	<switch>
		<when property="$as3">
			<passthrough>
				import flash.system.Capabilities;
				import flash.external.ExternalInterface;
			</passthrough>
		</when>
	</switch>
	<attribute name="counterror" type="number" value="0" />
	
	<attribute name="loaderVar" value="null" />
	
	<attribute name="userScope" value="hibernate" type="string" />
	
	<!-- refreshing the session regulary -->
	<attribute name="refreshDelegate" value="null" />
	
	<!-- UserId-->
	<attribute name="UserID" value="1" type="number" />
	<!-- reconnect after each conferenceView -->
	<attribute name="reconnectedRoomInstance" value="null" />
	
	<attribute name="reconnectionAction" value="false" type="boolean" />
	<attribute name="reconnectObjRef" value="null" />
		 
	 <attribute name="userobject" value="null" />
	 
	 <!-- default will be loaded on startup -->
	 <attribute name="userlang" value="1" type="number" />
	 
	 <!-- The default Language will be loaded on init  -->
	 <attribute name="initlanguageLoaded" value="false" type="boolean" />
	 
	 <!-- This domain is the orgdomain used in the video-conference -->
	 <attribute name="conferencedomain" value="public" type="string" />
	 
	 <!-- if this connection is used for testing the app
	 see test-setup.lzx -->
	 <attribute name="testAppLoading" value="false" type="boolean" />
	 
	 <!-- 
		the real ROOM_ID
	 -->
	 <attribute name="currentroomid" value="0" type="number" />
	 
	<!-- shows what kind of conferenceView it is at the moment
		wether its conferenceView or audienceView -->
	<attribute name="modus" value="" type="string" />
	
	<attribute name="showKickMessage" value="false" type="boolean"/>
		 
	<attribute name="useRTMPT" value="false" type="boolean" />
	<attribute name="connected" value="false" type="boolean" />
	
	<method name="getProtocol">
		if (canvas.useSSL) {
			return "rtmps";
		}
		if (this.useRTMPT) {
			return "rtmpt";
		}
		return "rtmp";
	</method>
	
	<method name="getPort">
		if (canvas.useSSL) {
			return canvas.rtmpsslport;
		}
		if (this.useRTMPT) {
			return canvas.red5httpport;
		}
		return canvas.rtmpport;
	</method>
	
	<method name="getHost">
		return canvas.rtmphostlocal;
	</method>
	
	<method name="getWebappRootKey">
		return canvas.webAppRootKey;
	</method>
		 
	<!-- 
		canvas.getUrl() can not be reused since it has different protocol and port 
		and potentially in cluster another host, the only thing that stays the same
		no matter if hosted on slave or on master, is the scope, so
		userScope always stays the same
	 -->
	<method name="getUrl">
		return this.getProtocol() + '://' + this.getHost() + ':' + this.getPort() 
					+ '/' + this.getWebappRootKey() + '/' + this.userScope;
	</method>
			 
	 <!--
		The onconnect Method is triggered several times:
			 - When you enter a room the NetConnection will close and reconnect to the Scope of the Room
			 - When you leave the room again it will be re-connected to the default scope again
	  -->
	 <handler name="onconnect">
		if($debug) Debug.write("hibRtmpConnection/onconnect");
		if (this.reconnectionAction){
			if (!!canvas.wicketsid) {
				canvas.sessionId = canvas.wicketsid;
				getDefaultLanguage.doCall();
			}
		} else if (!!canvas.wicketsid) {
			canvas.sessionId = canvas.wicketsid;
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.setProgress();
			}
			getDefaultLanguage.doCall();
			this.refreshDelegate = new LzDelegate(this, "refreshSessionMeth");
			lz.Timer.addTimer(this.refreshDelegate, canvas.refreshSession);
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.setProgress();
			}
		}
		connected = true;
		client.roomConnect = this.roomConnect;
		client.roomDisconnect = this.roomDisconnect;
		client.addNewUser = this.addNewUser;
		client.sendVarsToMessage = this.sendVarsToMessage;
		client.sendVarsToMessageWithClient = this.sendVarsToMessageWithClient;
		client.sendVarsToWhiteboardById = this.sendVarsToWhiteboardById;
		client.sendVarsToModeratorGeneral = this.sendVarsToModeratorGeneral;
		client.sendSyncFlag = this.sendSyncFlag;
		client.sendSyncCompleteFlag = this.sendSyncCompleteFlag;
		client.sendObjectSyncFlag = this.sendObjectSyncFlag;
		client.sendObjectSyncCompleteFlag = this.sendObjectSyncCompleteFlag;
		client.loadWmlToWhiteboardById = this.loadWmlToWhiteboardById;
		client.newMessageByRoomAndDomain = this.newMessageByRoomAndDomain;
		client.interviewStatus = this.interviewStatus;
		client.newStream = this.newStream;
		client.closeStream = this.closeStream;
		//TODO FIXME method is absent :( client.stopStream = this.stopStream;
		//TODO FIXME method is absent :( sendImagesSyncCompleteFlag
		client.receiveExclusiveAudioFlag = this.receiveExclusiveAudioFlag;
		client.setNewModeratorByList = this.setNewModeratorByList;
		client.newScreenSharing = this.newScreenSharing;
		client.stopScreenSharingMessage = this.stopScreenSharingMessage;
		client.stopPublishingMessage = this.stopPublishingMessage;
		client.newRed5ScreenCursor = this.newRed5ScreenCursor;
		client.nickNameSet = this.nickNameSet;
		client.startedPublishing = this.startedPublishing;
		client.newPoll = this.newPoll;
		client.clientUpdated = clientUpdated;
	</handler>
	
	<handler name="ondisconnect">
		connected = false;
	</handler>
	
	<method name="reconnectComplete">
		if (this.reconnectionAction){
			this.reconnectionAction = false;
		}
		canvas.currentContentView.sendInit.sendEvent(this);
	</method>
	
	<handler name="onerror" >
	<![CDATA[
		canvas.remoteLogWrite("error status='" + this.status + "'; src='" + this.src + "'; lastCalled='" + this.lastCalled
			+ "'; showKickMessage='" + this.showKickMessage + "'; reconnectionAction='" + this.reconnectionAction + "'");
		if (this.showKickMessage) {
			new lz.labelerrorPopup(canvas,{
				errorlabelid:606
				, closeFunc: function() {
					canvas.quit();
				}
			});
			canvas._loadingAll.hideContentOnly();
			return;
		} else if (this.reconnectionAction){
			if ($debug) Debug.write("this.reconnectionAction: ", this.lastCalled);
			this.connect();
		} else {
			this.useRTMPT = true
			var src = getUrl();
			this.setAttribute('src',src);
			//Debug.write("new src ",this.src);
			if (this.counterror < 3) {
				this.counterror++;
				if (canvas.thishib.loaderVar != null) {
					canvas.thishib.loaderVar.error.setAttribute('text',"try "+this.counterror);
				}
				if ($debug) Debug.write("Reconnecting: ", this.counterror);
				this.connect();
			} else {
				//Debug.write("connection failed");
				if (canvas.thishib.loaderVar != null) {
					canvas.thishib.loaderVar.error.setAttribute('text',this.status);
				}
				canvas.setAttribute('loadingmessage','connection failed');
				new lz.labelerrorPopup(canvas,{errorlabelid:556});
			}
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar._src.setAttribute('text',src);
			}
		}
	]]>
	</handler>	
	
	<method name="refreshSessionMeth" args="calleeObj">
		this.refreshSession.doCall();
	</method>
	
	<!-- This Function is just for refreshing the Session -->
	<netRemoteCallHib name="refreshSession" funcname="userservice.refreshSession" showLoading="false" >	
		<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
		<handler name="ondata" args="value">
			//if ($debug) Debug.write("hibRtmpConnection/refreshSession [",value,"]");
			lz.Timer.addTimer(parent.refreshDelegate, canvas.refreshSession);
		</handler>
	</netRemoteCallHib>

	<netRemoteCallHib name="getPublicSID" funcname="getPublicSID" >	  
		<handler name="ondata" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("hibRtmpConnection/getPublicSID [",value,"]");
			canvas.publicSID = value;	 
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.setProgress();
			}
			parent.getDefaultLanguage.doCall();
		</handler>  
	</netRemoteCallHib>
	
	<netRemoteCallHib name="overwritePublicSID" funcname="overwritePublicSID" >	 
		<netparam><method name="getValue"> return canvas.publicSID;</method></netparam>
		<handler name="ondata" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("overwritePublicSID: ",value);
		</handler>  
	</netRemoteCallHib>	
	
	<method name="setDefaultUserLanguage">
		<![CDATA[
			if (userlang == -1 && canvas.language_id != 0) {
				userlang = canvas.language_id;
			} else if (userlang == -1) {
				userlang = canvas.default_lang_id;
			}
		]]>
	</method>
	
	<netRemoteCallHib name="setUsernameReconnect" funcname="setUsernameReconnect" remotecontext="$once{ canvas.thishib }" >   
		<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
		<netparam><method name="getValue">return canvas.userId;</method></netparam>
		<netparam><method name="getValue">return canvas.currentuser;</method></netparam>
		<netparam><method name="getValue">return canvas.firstName;</method></netparam>
		<netparam><method name="getValue">return canvas.lastName;</method></netparam>   
		<netparam><method name="getValue">return canvas.picture_uri;</method></netparam>   
		<handler name="ondata" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("setUsernameReconnect: ",canvas.userId,value);   
			parent.reconnectComplete();
		</handler>  
	</netRemoteCallHib>	
		
	<netRemoteCallHib name="getDefaultLanguage" funcname="languageservice.getDefaultLanguage" >	  
		<handler name="ondata" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			canvas.default_lang_id = value;
			if ($debug) Debug.write("getDefaultLanguage: ",value,"; canvas.lang = ", canvas.language_id);
			if (canvas.language_id==0){
				parent.userlang = canvas.default_lang_id;
			} else {
				parent.userlang = canvas.language_id;
			}
			parent.getLanguageByIdAndMax.doCall();
		</handler>
	</netRemoteCallHib>
	
	<netRemoteCallHib name="getCurrentRoomClient" funcname="xmlcrm.getCurrentRoomClient" >
		<netparam name="sessionId"><method name="getValue">return canvas.sessionId;</method></netparam>
		<handler name="ondata" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("getCurrentRoomClient: ", value);
			if (value != null) {
				canvas.currentClient = value;
				canvas.setAttribute('currentuser', value.firstname+" "+value.lastname);
				
				//Somehow this leads to a bug in the implementation of the secure User Login
				canvas.setAttribute('userId', value.userId);
				
				canvas.setAttribute('allowRecording', value.allowRecording);
				
				var fName = value.firstname == null ? "" : value.firstname;
				var lName = value.lastname == null ? "" : value.lastname;
				canvas.setAttribute('firstName', fName);
				canvas.setAttribute('lastName', lName);
				canvas.setAttribute('mail', value.email);
				
				hib.userobject.id = value.userId;
				hib.userobject.firstname = fName;
				hib.userobject.lastname = lName;
				
				canvas.setAttribute('lastLogin','');
				canvas.setAttribute('picture_uri',value.picture_uri);
				canvas.setAttribute('language','');
				canvas.setRoomValues(canvas.currentRoomObj);
			}
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.close();
			}
			if ($debug) Debug.write("getCurrentRoomClient: ", canvas.currentClient);
		]]>
		</handler>
	</netRemoteCallHib>

	<netRemoteCallHib name="getLanguageByIdAndMax" funcname="languageservice.getLanguageByIdAndMax" >
		<attribute name="start" value="0" type="number" />
		<attribute name="step" value="100" type="number" />
		<attribute name="max" value="1607" type="number" />
		<netparam><method name="getValue">return parent.parent.userlang;</method></netparam> 
		<netparam><method name="getValue">return parent.start;</method></netparam> 
		<netparam><method name="getValue">return parent.step;</method></netparam> 
		<handler name="ondata" args="value">
			<![CDATA[
			if($debug) Debug.write("hibRtmpConnection/userlang:[",parent.userlang,"]");
				//if($debug) Debug.write("hibRtmpConnection/getLanguageByIdAndMax:[",value,"]");
				setLabelObjectByHundred(this.start,value);
				//The onResult-Handler will be called be the rtmpconnection
				if (this.start <= max){
					this.start += this.step;
					if (canvas.thishib.loaderVar != null) {
					   canvas.thishib.loaderVar.setProgress();
					}
					this.doCall();
				} else {
					if($debug) Debug.write("loading lang complete");
					if (parent.initlanguageLoaded){
						if (canvas.thishib.loaderVar != null) {
							canvas.thishib.loaderVar.setProgress();
						}
						parent.setUsernameAndSession.doCall();
					} else {
						parent.initlanguageLoaded = true;
						if($debug) Debug.write("getGeneralOptions");
						parent.getGeneralOptions.doCall();
					}
				}
			]]>
		</handler>  
	</netRemoteCallHib>
		
	<method name="setUser" args="user">
		if (!user) {
			new lz.errorPopup(canvas,{error:"Missing User Object"});
		}
		hib.userobject = user;
		canvas.userId = hib.userobject.id;
	</method>
	
	<netRemoteCallHib name="getGeneralOptions" funcname="xmlcrm.getGeneralOptions">
		<handler name="ondata" args="value">
		<![CDATA[
			if (canvas.thishib.loaderVar != null) {
				canvas.thishib.loaderVar.setProgress();
			}
			if ($debug) Debug.write("getGeneralOptions: ", value.length, value);
			if (value != null) {
				if (value.length > 0 && value[0] != null) {
					//if ($debug) Debug.write("Give exclusive audio keycode is: ", value[0].value);
					canvas.setAttribute('GIVE_EXCLUSIVE_AUDIO_KEY', value[0].value);
				}
				if (value.length > 1 && value[1] != null) {
					if ($debug) Debug.write("red5sip.enable is: ", value[1].value);
					canvas.setAttribute('RED5_SIP_ENABLE', value[1].value);
				}
				if (value.length > 2 && value[2] != null) {
					if ($debug) Debug.write("max_upload_size is: ", value[2].value);
					canvas.setAttribute('MAX_UPLOAD_SIZE', value[2].value);
				}
				if (value.length > 3 && value[3] != null) {
					if ($debug) Debug.write("Mute/unmute keycode is: ", value[3].value);
					canvas.setAttribute('MUTE_AUDIO_KEY', value[3].value);
				}
				if (value.length > 4 && value[4] != null) {
					if ($debug) Debug.write("redirect.url.for.external.users is: ", value[4].value);
					canvas.setAttribute('REDIRECT_URL_FOR_EXTERNAL_USERS', value[4].value);
				}
			} else {
				if ($debug) Debug.warn("xmlcrm.getGeneralOptions empty!");
			}
			if (canvas.wicketsid != null) {
				parent.loginWicket.doCall();
			}
		]]>
		</handler>
	</netRemoteCallHib>
	
	<netRemoteCallHib name="loginWicket" funcname="xmlcrm.loginWicket" >
		<netparam><method name="getValue">return canvas.wicketsid;</method></netparam>
		<netparam><method name="getValue">return canvas.wicketroomid;</method></netparam>
		<handler name="ondata" args="value">
		<![CDATA[
			if ($debug) Debug.write("!!!!!!!!!!! loginWicket", value);
			if (value != null) {
				var user = value[0];
				canvas.setAttribute('userId', user.id);
				canvas.setAttribute('firstName', user.firstname == null ? "" : user.firstname);
				canvas.setAttribute('lastName', user.lastname == null ? "" : user.lastname);
				canvas.setAttribute('mail','');
				canvas.setAttribute('lastLogin','');
				canvas.setAttribute('picture_uri','');
				canvas.setAttribute('language','');
				canvas.setAttribute('currentuser', user.login);
				if (user.timeZoneId != null) {
					canvas.timeZoneId = user.timeZoneId;
				}
				if (user.rights != null) {
					canvas.becomemoderator = user.rights.indexOf('Admin') > -1;
				}
				if ($debug) Debug.write("hibRtmpConnection::loginWicket -> canvas.becomemoderator", canvas.becomemoderator);
				if (user.sessionData == null) {
					if ($debug) Debug.write("No Language Found to assign");
					return;
				}
				hib.userobject = user;
				canvas.currentRoomObj = value[1];
				parent.getCurrentRoomClient.doCall();
			} else {
				new lz.labelerrorPopup(canvas, {errorlabelid: 1599});
			}
		]]>
		</handler>
	</netRemoteCallHib>
	
		<netRemoteCallHib name="setUsernameAndSession" funcname="setUsernameAndSession" remotecontext="$once{ canvas.thishib }" >   
			<netparam><method name="getValue"> return canvas.sessionId; </method></netparam> 
			<netparam><method name="getValue">return canvas.userId;</method></netparam>
			<netparam><method name="getValue">return canvas.currentuser;</method></netparam>
			<netparam><method name="getValue">return canvas.firstName;</method></netparam>
			<netparam><method name="getValue">return canvas.lastName;</method></netparam>	  
			<handler name="ondata" args="value">
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) Debug.write("setUsernameAndSession: ",canvas.userId,value);
				if (canvas.thishib.loaderVar != null) {
					canvas.thishib.loaderVar.close();
				}
			</handler>  
		</netRemoteCallHib>		
		
		<netRemoteCallHib name="testMethod" funcname="testMethod">
			<handler name="ondata" args="value">
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) Debug.write("testMethod ",value);				   
			</handler>  
		</netRemoteCallHib>

		<!--- Notification of new User --> 
		<method name="addNewUser" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("addNewUser: ",value);
			if(value.sipTransport) {
				canvas._videocontainer.addItem(value.connectedSince,value.isMod,value.streamid,value.roomId,'',value.formatedDate,value.userpos,value.usercolor,value);
			} else {
				canvas._videocontainer.addClientItem(value.connectedSince,value.isMod,value.streamid,value.roomId,'',value.formatedDate,value.userpos,value.usercolor,value);
			}
			canvas.setAttribute('numberofpartners',canvas.numberofpartners+1);
		</method>	
		
		<netRemoteCallHib name="getCurrentModeratorList" funcname="getCurrentModeratorList">
			<handler name="ondata" args="value">
				<![CDATA[
					if ($debug) Debug.write("############ getCurrentModeratorList: ",value);
					
					canvas.analyzeModerationList(value);
					
					canvas.currentModeratorList = value;
					//Update Moderation Flag
					canvas.updateModerationFlag();
					
					var messageAlreadyThrown = false;
					
					//if ($debug) Debug.write("throw event to drawarea: ", canvas.moderatorStreamID, canvas.ismoderator);
					
					canvas._drawarea.onopenWhiteBoard.sendEvent();
					
					if ($debug) Debug.write("room ", canvas.currentRoomObj);
					if ($debug) Debug.write("room.type ", canvas.currentRoomObj.type);
					
					if (canvas.currentRoomObj.type != 'restricted') {
						if (canvas.currentRoomObj.moderated) {
							if (value.length == 0 && !messageAlreadyThrown){
								new lz.labelerrorPopup(canvas,{errorlabelid:641});
							}
						} else {
							if (value.length == 0 && !messageAlreadyThrown){
								new lz.errorModeratorPopup(canvas,{error:canvas.getLabelName(498)});
							}
						}
					}
				]]>
			</handler>
		</netRemoteCallHib>
		
		<method name="newStream" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("newStream: ",value);
			if (value == null || value.screenClient) {
				return;
			}
			canvas.commonVideoViewContent.startStream(value);
		</method> 
		   
		<method name="closeStream" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("**** closeStream: ",value);
			if (value == null) {
				return;
			}
			if (value.screenClient) {
				if ($debug) Debug.write(" ondata closeStream: ",value.streamPublishName); 
				canvas.commonVideoViewContent.closeScreenSharing(value);
			} else {
				//free the VideoContainer
				//canvas._videocontainer.closeStreamClient(value.publicSID);
				canvas.commonVideoViewContent.closeStreamClient(value.publicSID);
				canvas.setAttribute('numberofpartners',canvas.numberofpartners-1);
			}
			//TODO:check first current tab
		</method>  
		
		<!---
			Event is invoked if a red5 stream sharing is closed
		 -->
		<method name="stopScreenSharingMessage" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("**** closeStream: ",value);
			if ($debug) Debug.write(" onResult stopScreenSharingMessage : ",value.streamPublishName);
			canvas.commonVideoViewContent.closeScreenSharing(value);
		</method> 
			 
		<netRemoteCallHib name="clientregisterRoom" funcname="clientregisterRoom">
			<handler name="ondata" args="value">
				if ($debug) Debug.write("**** clientregisterRoom::ondata ", value);
			</handler>   
		</netRemoteCallHib>   

		<method name="roomDisconnectUser" args="value,id">
			canvas._videocontainer.disconnectclient(id);
			if (canvas.commonVideoViewContent != null) {
				canvas.commonVideoViewContent.disconnectclient(id);
				if (canvas.currentModApply != null) canvas.currentModApply.rejectUser(value);
				if (value.isRecording) {
					canvas._mymod.recordingUser = null;
				}
				if (value.streamPublishStarted) {
					canvas._mymod.publishingObj = null;
				}
				canvas._mymod.setMessage();
			}
		</method>
		
		<method name="roomDisconnect" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("roomDisconnect: ", value);
			if (value == null || value.screenClient) {
				return;
			}
			this.roomDisconnectUser(value, value.publicSID);
		]]>
		</method>
		
		<method name="stopPublishingMessage" args="value">
			//The onResult-Handler will be called be the rtmpconnection
			canvas._mymod.publishingObj = null;
			canvas._mymod.setMessage();				 
		</method>
		
		<netRemoteCallHib name="setSyncFlag" funcname="setSyncFlag" >	  
			<handler name="ondata" args="value">
				if ($debug) Debug.write("setSyncFlag: ",value);
			</handler>
		</netRemoteCallHib>   
			 
		<method name="setUserStatus" args="ctx,user,o">
			<![CDATA[
				if (!o || !user) return;
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) {
					Debug.write("setUserStatus: ", user);
					Debug.write("setUserStatus: ", o.param);
				}
				var aObj = o.param[3];
				var usPoint = null;
				if ($debug) Debug.write("drawObj: ", aObj[0]);
				switch(aObj[0]) {
					case 'line':
					case 'uline':
						usPoint = {x: aObj[aObj.length - 5] + aObj[6], y: aObj[aObj.length - 4] + aObj[7]};
						break;
					case 'letter':
					case 'rectangle':
					case 'ellipse':
					case 'clipart':
						usPoint = {x: aObj[aObj.length - 3] + aObj[aObj.length - 5], y: aObj[aObj.length - 2] + aObj[aObj.length - 4]};
						break;
					case 'paint':
						var points = aObj[1];
						//points are empty on 'paint' move
						usPoint = {
							x: aObj[aObj.length - 5] + (points.length ? points[points.length - 1][3] : aObj[aObj.length - 3])
							, y: aObj[aObj.length - 4] + (points.length ? points[points.length - 1][4] : aObj[aObj.length - 2])};
						break;
					case 'drawarrow':
						usPoint = {x: aObj[aObj.length - 5] + aObj[9], y: aObj[aObj.length - 4] + aObj[10]};
						break;
				}
				if (usPoint) {
					var us = new lz.userStatus(ctx, {
						width:100
						, x: usPoint.x
						, y: usPoint.y - 25 //little above
						, queueable: false
						, statusText: user.firstname + " " + user.lastname
						});
					if ($debug) Debug.write("us: ", us, "; usPoint: ", usPoint);
				}
			]]>
		</method>

		<method name="sendVarsToWhiteboardById" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("sendVarsToWhiteboardById : ", value);
			this.setUserStatus(canvas._drawarea, value[0], value[1]);
			canvas._drawarea.parent.parent.parent.sendWatchObjectByWhiteboard(value[1]);
		]]>
		</method> 
		
		<method name="loadWmlToWhiteboardById" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("loadWmlToWhiteboardById : ",value);
			canvas._drawarea.parent.parent.parent.loadWmlToWhiteboardById(value);
		]]>
		</method>
		
		<netRemoteCallHib name="giveExclusiveAudio" funcname="giveExclusiveAudio">
			<attribute name="publicSID" value="0" type="string" />
			<netparam><method name="getValue">return parent.publicSID;</method></netparam>
			<method name="setExclusiveAudio" args="tPublicSID">
				this.publicSID = tPublicSID;
				this.doCall();
			</method>
		</netRemoteCallHib>

		<method name="receiveExclusiveAudioFlag" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			canvas._videocontainer.receiveExclusiveAudioFlag(value.publicSID)
		]]>
		</method>

		<netRemoteCallHib name="switchMicMuted" funcname="switchMicMuted">
			<attribute name="publicSID" value="" type="string" />
			<attribute name="mute" value="false" type="boolean" />
			<event name="onMute" />
			<method name="setMute" args="tPublicSID,tMute">
				this.publicSID = tPublicSID;
				this.mute = tMute;
				var obj = new Array();
				obj["mute"] = tMute;
				obj["publicSID"] = tPublicSID;
				this.onMute.sendEvent(obj);
				this.doCall();
			</method>
			<netparam><method name="getValue">return parent.publicSID;</method></netparam>
			<netparam><method name="getValue">return parent.mute;</method></netparam>
		</netRemoteCallHib>

		<method name="newRed5ScreenCursor" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			//if ($debug) Debug.write(" onResult newRed5ScreenCursor : ",value);
			canvas.commonVideoViewContent.updateCursorScreenSharing(value);
		]]>
		</method>
		
		<!--
			Red5 Screen Sharing
		 -->
		<method name="newScreenSharing" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			//if ($debug) Debug.write(" onResult newScreenSharing 1 : ",value);
			//if ($debug) Debug.write(" onResult newScreenSharing 2 : ",value.streamid);
			//if ($debug) Debug.write(" onResult newScreenSharing 3 : ",canvas.streamid);
			if ($debug) Debug.write(" onResult newScreenSharing 4 : ",value.streamPublishName);
			if ($debug) Debug.write(" onResult newcreenSharing 5 : ",canvas.publicSID);
			
			canvas.commonVideoViewContent.newScreenSharing(value);
		]]>
		</method>
		
		<netRemoteCallHib name="checkScreenSharing" funcname="checkScreenSharing">
			<handler name="ondata" args="value">
			<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) Debug.write(" onResult checkScreenSharing : ",value);  
				if (value != null) {
					canvas.commonVideoViewContent.newScreenSharings(value);
				} else {
					if ($debug) Debug.warn("Self Screen Sharing");
				}
			]]>
			</handler>   
		</netRemoteCallHib>
		
		<netRemoteCallHib name="setCanDraw" funcname="whiteboardservice.setCanDraw"
					   remotecontext="$once{ canvas.thishib }">
			<attribute name="publicSID" value="" type="string" />
			<attribute name="canDraw" value="true" type="boolean" />
			<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
			<netparam><method name="getValue">return parent.publicSID;</method></netparam>
			<netparam><method name="getValue">return parent.canDraw;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
					//The onResult-Handler will be called be the rtmpconnection
					if ($debug) Debug.write("setCanDraw : ",value);
				]]>
			</handler>   
		</netRemoteCallHib>
		
		<netRemoteCallHib name="setCanShare" funcname="whiteboardservice.setCanShare"
					   remotecontext="$once{ canvas.thishib }">
			<attribute name="publicSID" value="" type="string" />
			<attribute name="canShare" value="true" type="boolean" />
			<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
			<netparam><method name="getValue">return parent.publicSID;</method></netparam>
			<netparam><method name="getValue">return parent.canShare;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
					//The onResult-Handler will be called be the rtmpconnection
					if ($debug) Debug.write("setCanShare : ",value);
				]]>
			</handler>   
		</netRemoteCallHib>
		
		<netRemoteCallHib name="setCanRemote" funcname="whiteboardservice.setCanRemote"
					   remotecontext="$once{ canvas.thishib }">
			<attribute name="publicSID" value="" type="string" />
			<attribute name="canRemote" value="true" type="boolean" />
			<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
			<netparam><method name="getValue">return parent.publicSID;</method></netparam>
			<netparam><method name="getValue">return parent.canRemote;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
					//The onResult-Handler will be called be the rtmpconnection
					if ($debug) Debug.write("setCanRemote : ",value);
				]]>
			</handler>   
		</netRemoteCallHib>
		
		<method name="setNewModeratorByList" args="value">
		<![CDATA[
			if ($debug) Debug.write("setNewModeratorByList ",value);
			canvas.analyzeModerationList(value);
			
			//The onResult-Handler will be called be the rtmpconnection
			canvas.currentModeratorList = value;
			//Update Moderation Flag
			canvas.updateModerationFlag();
		]]>
		</method> 
		
		<netRemoteCallHib name="sendMessage" funcname="sendMessage">
			<netparam name="vars"><method name="getValue">return canvas.objMessage;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				//Debug.write("getValue : ",value);
				
				]]>
			</handler>   
		</netRemoteCallHib> 
		
		<netRemoteCallHib name="sendMessageAll" funcname="sendMessageAll">
			<netparam name="vars"><method name="getValue">return canvas.objMessage;</method></netparam>
			<handler name="ondata" args="value">
				<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				//Debug.write("getValue : ",value);
				]]>
			</handler>   
		</netRemoteCallHib> 
		
		<method name="clientUpdated" args="client">
		<![CDATA[
			if ($debug) Debug.write("clientUpdated changes ###### ");
			if (client.publicSID == canvas.publicSID) {
				if ($debug) Debug.write("Its about You ", client);
				canvas.setAttribute("isAllowedToDraw", client.canDraw);
				canvas.setAttribute("isAllowedToScreenShare", client.canShare);
				canvas.setAttribute("isAllowedToRemoteControl", client.canRemote);
				canvas.setAttribute("ismoderator", client.isMod);
				
				canvas.commonVideoViewContent.toggleVideo(client.canVideo);
				canvas.setAttribute("isBroadCasting", client.isBroadcasting);
				canvas.setAttribute("canVideo", client.canVideo);
				
				if (client.isBroadcasting) {
					if (canvas.thishib.modus == "interview") {
						canvas._drawarea.newInterviewStarting(client);
					} else {
						canvas.commonVideoViewContent.createEditRecordStream(false, false, -1);
					}
					canvas.setAttribute("lastBroadCastingUser", client);
				} else {
					if (canvas.inner.editRecordStream != null) {
						canvas.inner.editRecordStream.destroy();
					}
				}
			}
		]]>
		</method>
		
		<method name="sendVarsToMessage" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			//if ($debug) Debug.write("sendVarsToMessage : ", value);
			if (value[0]=='audioActivity'){
				//canvas.currentModApply
				//if ($debug) Debug.write("audioActivity Client ",value[1],value[2]);
				canvas.commonVideoViewContent.setSpeakingByPos(value[2], value[1]);
				ExternalInterface.call("audioActivity", value[2], value[1]);
			} else if (value[0]=='typingActivity'){
				if ($debug) Debug.write("!!!typingActivity ::", value[1], value[2]);
				ExternalInterface.call("typingActivity", value[2], value[1]);
			} else if (value[0]=='activateWhiteboard'){
				// Not Used
				//Debug.warn("Not Used");
				canvas._drawarea.parent.parent.parent.activateWhiteboard(value);
			} else if (value[0]=='newWhiteboard'){
				// Not Used
				//Debug.warn("Not Used");
				canvas._drawarea.parent.parent.parent.newWhiteboard(value);
			} else if (value[0]=='removeWindow'){
				// Not Used
				//Debug.warn("Not Used");
				canvas._drawarea.parent.parent.parent.removeWindow(value);
			} else if(value[0]=='fileslist'){
				canvas.currentImagesListdraw.parent.onvisible.sendEvent(true);
			}
		]]>
		</method>
		   
		<netRemoteCallHib name="sendVarsModeratorGeneral" funcname="sendVarsModeratorGeneral">
			<netparam name="vars"><method name="getValue">return canvas.VarsModeratorGeneral;</method></netparam>
			<handler name="ondata" args="value">
			<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				//Debug.write("sendVarsModeratorGeneral : ",value);
				
			]]>
			</handler>
		</netRemoteCallHib>

		<netRemoteCallHib name="sendMessageWithClient" funcname="sendMessageWithClient"
						  remotecontext="$once{ canvas.thishib }" >
			
			<attribute name="messageObj" value="null" />
			<method name="sendMessage" args="typeName,messageObject">
				this.messageObj = new Object();
				this.messageObj[0] = typeName;
				this.messageObj[1] = messageObject;
				this.doCall();
			</method>
			
			<method name="sendAdvMessage" args="typeName,messageObject,tStamp">
				this.messageObj = new Object();
				this.messageObj[0] = typeName;
				this.messageObj[1] = messageObject;
				this.messageObj[2] = tStamp;
				this.doCall();
			</method>
			
			<netparam name="vars"><method name="getValue">return parent.messageObj;</method></netparam>
			<handler name="ondata" args="value">
				//The onResult-Handler will be called be the rtmpconnection
				//Debug.write("sendMessageWithClient : ",value);
			</handler>
		</netRemoteCallHib>
		  
		<method name="sendVarsToMessageWithClient" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			if ($debug) Debug.write("sendVarsToMessageWithClient : ", value,value.message, value.message[0]);
			if (value[0] == 'kick' || value.message[0] == 'kick') {
				if ($debug) Debug.write("!!!!!! THIS USER GOING TO BE KICKED");
				this.showKickMessage = true;
				this.disconnect();
			} else if (value.message[0]=='copiedText'){
				//canvas.currentModApply
				
				if ($debug) Debug.info("copiedText :: ",value.message[1]);
				//System.setClipboard(value.message[1]);
				//lz.Browser.setClipboard(value.message[1]);
				//LzBrowserKernel.setClipboard (value.message[1]);
				//import flash.System;
				//flash.System.setClipboard(value.message[1]);
				
				new lz.copiedTextPopup(canvas,{error:value.message[1]});
			} else if (value.message[0]=='applyforMod'){
				//canvas.currentModApply
				if (canvas.streamid!=value.client.streamid) {
					new lz.responseForModeration(canvas.main_content._content.inner,{
							userobject:value.client,
							clientId:value.client.streamid
						});
				}
			} else if (value.message[0]=='applyModAnswer'){
				canvas.currentModApply.setUserAnswer(value);
			} else if (value.message[0]=='avsettings'){
				canvas.commonVideoViewContent.setAVSettingsToClient(value.client);
			} else if (value.message[0]=='whiteboard'){
				//if (value.message[1]=='wmlloadcomplete'){
				//	canvas._drawarea.sendCompleteWmlLoadedRClient(value.client);
				//} else if (value.message[1]=='wmlsynccomplete'){
				//	canvas._drawarea.sendCompleteWmlSync(value.client);
				//} else
				if (value.message[1]=='imageloadcomplete'){
					canvas._drawarea.sendCompleteImageLoadedRClient(value.client);
				} else if (value.message[1]=='imagesynccomplete'){
					canvas._drawarea.sendCompleteImageSync(value.client);
				} else if (value.message[1]=='imageloaderror'){
					canvas._drawarea.sendCompleteImageLoadedRClient(value.client);
				} else if (value.message[1]=='imageloadtimeout'){
					canvas._drawarea.sendCompleteImageLoadedRClient(value.client);
				} else if (value.message[1]=='swfloadcomplete'){
					canvas._drawarea.sendCompleteSWFLoadedRClient(value.client);
				} else if (value.message[1]=='swfsynccomplete'){
					canvas._drawarea.sendCompleteSWFSync(value.client);
				} else if (value.message[1]=='swfloaderror'){
					canvas._drawarea.sendCompleteSWFLoadedRClient(value.client);
				} else if (value.message[1]=='swfloadtimeout'){
					canvas._drawarea.sendCompleteSWFLoadedRClient(value.client);
				} else if (value.message[1]=='inituser'){
					//this message is deprecated and can be removed!
					//swagner 12.06.2008
					//canvas._drawarea.sendCompleteImageSync(value.client);
					if ($debug) Debug.write("inituser loadwmlObjectToStage: ",value.message[2]);
					if (!canvas.ismoderator) canvas._drawarea.loadwmlObjectToStage(value.message[2],"","","",true,true);
				} else if (value.message[1]=='initgetVars'){
					//canvas._drawarea.sendCompleteImageSync(value.client);
					//Debug.write("initgetVars sendVarsToMessageWithClient: ",value.message[2]);
					canvas._drawarea.sendWatchObject(value.message[1],value.message[2],false);
				} else if (value.message[1]=='syncinitLoader'){
					//canvas._drawarea.sendCompleteImageSync(value.client);
					//Debug.write("syncinitLoader sendVarsToMessageWithClient: ",value.message[2]);
					if (value.client.streamid!=canvas.streamid) canvas._drawarea.remoteSyncLoader();
				} else if (value.message[1][0]=='isSnapToGrid'){
					canvas._drawarea.setAttribute('isSnapToGrid', value.message[1][1]);
					//Debug.write("syncinitLoader sendVarsToMessageWithClient: ",value.message[2]);
					//if (value.client.streamid!=canvas.streamid) canvas._drawarea.remoteSyncLoader();
				}
			} else if (value.message[0]=='updateMuteStatus'){
				canvas.setMuteStatus(value.message[1]);
			} else if (value.message[0]=='updateDrawStatus'){
				canvas.setDrawAllowStatus(value.message[1]);
				//Notify all Listeners for change of the item
				canvas.setAttribute("drawAllowStatus",value.message[1]);
			} else if (value.message[0]=='updateGiveAudioStatus') {
				canvas.setExclusiveAudioAllowStatus(value.message[1]);
				canvas.setAttribute("exclusiveAudioAllowStatus",value.message[1]);
			} else if (value.message[0] == 'personal') {
				var pSID = value.client.publicSID;
				var vo = canvas._videocontainer._participants.getUserListItemByPublicSID(pSID);
				if (vo != null) {
					vo.setAttribute('lastname', value.message[2]);
					vo.refObj.lastname = value.message[2];
				}
				canvas.commonVideoViewContent.updateFirstLastName(pSID, value.message[1], value.message[2]);
			} else {
				if ($debug) Debug.warn("sendVarsToMessageWithClient unkown message ",value);
			}
		]]>
		</method>	 
	
		<method name="newMessageByRoomAndDomain" args="value">
		<![CDATA[
			if (value.message=='desktop'){
				canvas._drawarea.incomingScreenSharing(value);
			} else if (value.message=='library'){
				if (value.action == 'import') {
					canvas.currentUploadWindow.remoteComplete(value);
					return;
				}
			} else if (value.message=='startStreaming'){
				canvas._drawarea.startStreaming(value);
			} else if (value.message=='stopStreaming'){
				canvas._drawarea.stopStreaming(value);
			} else {
				if ($debug) Debug.warn("Unknown Event -newMessageByRoomAndDomain- ",value);
			}
		]]>
		</method>	  
			   
		<method name="sendVarsToModeratorGeneral" args="value">
		<![CDATA[
			//The onResult-Handler will be called be the rtmpconnection
			//Debug.write("sendVarsToModeratorGeneral : ",value);
			if (value[0]=='sharewhiteinit'){
				if (!canvas.htmlframeisloaded){
					canvas.ifrm.createIFrame();
					canvas.setAttribute('htmlframeisloaded',true);
				}
			}
		]]>
		</method>	   
		
	<netRemoteCallHib name="checkLzRecording" funcname="recordingservice.checkLzRecording" >	  
		<handler name="ondata" args="value">
			if ($debug) Debug.write("checkLzRecording: ",value);
			if (value != null) {
				canvas._mymod.recordingUser = value;
				canvas._mymod.setMessage();
			}
			parent.checkScreenSharing.doCall();
		</handler>
	</netRemoteCallHib>
	
	<method name="startedPublishing" args="value">
		if ($debug) Debug.write("startedPublishing: ", value);
		canvas._mymod.publishingObj = {user: value[0], url: value[1]};
		canvas._mymod.setMessage();
	</method>
	
	<method name="roomConnect" args="value">
		if ($debug) Debug.write("roomConnect: ",value);
		canvas._videocontainer.addItem(value.connectedSince,value.isMod,value.streamid,value.username,
				'',value.formatedDate,value.userpos,value.usercolor,value);
	</method>
	
	<method name="nickNameSet" args="value">
		if ($debug) Debug.write("nickNameSet: ", value);
		if (canvas.publicSID == value.publicSID) {
			canvas.currentClient = value;
			canvas.setAttribute('mail', value.email);
			canvas.setAttribute('firstName', value.firstname);
			canvas.setAttribute('lastName', value.lastname);
		}
		var v = canvas.commonVideoViewContent.getVideoObjectByPublicSID(value.publicSID);
		if (v != null) {
			v.setAttribute('chatpartnername', canvas.currentClient.firstname + ' ' + canvas.currentClient.lastname);
		}
		if (canvas._videocontainer) {
			var vo = canvas._videocontainer._participants.getUserListItemByPublicSID(value.publicSID);
			if (vo != null) {
				vo.update(value);
			}
		}
	</method>
	
	<!-- Whiteboard sync Events -->
	<method name="sendSyncFlag" args="value">
	<![CDATA[
		//The onResult-Handler will be called be the rtmpconnection
		if ($debug) Debug.write("sendSyncFlag: ",value);
		if (canvas.syncWindow == null) {
			canvas.syncWindow = new lz.syncWin(canvas.main_content._content.inner, {labelid: 558, labeliderror: 559});
		}
	]]>
	</method>	 
	
	<method name="sendSyncCompleteFlag" args="value">
	<![CDATA[
		//The onResult-Handler will be called be the rtmpconnection
		if ($debug) Debug.write("sendSyncCompleteFlag: ",value);
		if (canvas.syncWindow != null) {
			canvas.syncWindow.close();
			canvas.syncWindow = null;
		}
	]]>
	</method>  
	
	<!-- Whiteboard Object Sync Process -->
	<method name="sendObjectSyncFlag" args="value">
	<![CDATA[
		//The onResult-Handler will be called be the rtmpconnection
		if ($debug) Debug.write("sendObjectSyncFlag: ",value);
		if (canvas.syncImageWindow == null) {
			canvas.syncImageWindow = new lz.syncWin(canvas.main_content._content.inner, {labeliderror: 591});
		}
	]]>
	</method>	 
	
	<method name="sendObjectSyncCompleteFlag" args="value">
	<![CDATA[
		//The onResult-Handler will be called be the rtmpconnection
		if ($debug) Debug.write("sendObjectSyncCompleteFlag: ",value);
		if (canvas.syncImageWindow != null) {
			canvas.syncImageWindow.close();
			canvas.syncImageWindow = null;
		}
	]]>
	</method>  
	
	<!-- Recording of Meetings -->
	<method name="interviewStatus" args="value">
	<![CDATA[
		//The onResult-Handler will be called be the rtmpconnection
		if ($debug) Debug.write("interviewStatus: ",value);
		canvas._drawarea.reloadStatus();
	]]>
	</method>  
	
	<netRemoteCallHib name="setCanGiveAudio" funcname="whiteboardservice.setCanGiveAudio"
				   remotecontext="$once{ canvas.thishib }">
		<attribute name="publicSID" value="" type="string" />
		<attribute name="canGiveAudio" value="true" type="boolean" />
		<method name="sendValue" args="publicSID,giveAudio">
			this.publicSID = publicSID;
			this.canGiveAudio = giveAudio;
			this.doCall();
		</method>
		<netparam><method name="getValue">return canvas.sessionId;</method></netparam>
		<netparam><method name="getValue">return parent.publicSID;</method></netparam>
		<netparam><method name="getValue">return parent.canGiveAudio;</method></netparam>
		<handler name="ondata" args="value">
			<![CDATA[
				//The onResult-Handler will be called be the rtmpconnection
				if ($debug) Debug.write("setCanGiveAudio : ",value);
			]]>
		</handler>
	</netRemoteCallHib>
</class>

<hibRtmpConnection name="thishib" id="hib" />

</library>
